#!/usr/bin/env python3

import requests
import json
import logging
import asyncio
import time
from typing import Dict, List, Any, Optional
from openai import AsyncOpenAI
from langchain_openai import ChatOpenAI
from langchain_core.messages import SystemMessage, HumanMessage, AIMessage
import os
from dotenv import load_dotenv
from database.db_models import UserSession
from sqlalchemy.orm import Session
from utils.language_utils import language_handler
from services.data_api import data_api
from database.db_utils import get_db
from database.district_utils import district_lookup
import random

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Import message logger for detailed journey tracking
try:
    from utils.message_logger import message_journey_logger
    LOGGING_AVAILABLE = True
except ImportError:
    LOGGING_AVAILABLE = False
    logger.warning("Message journey logger not available - LLM logging disabled")

class QueryAgent:
    """
    Enhanced Query Agent with function calling capabilities for answering user queries 
    about water delivery services, cities, brands, and products
    Enhanced with brand extraction and improved context handling
    """
    
    def __init__(self):
        self.api_base_url = "http://localhost:8000/api"
        
        # Initialize LangChain OpenAI client for tracing
        openai_api_key = os.getenv("OPENAI_API_KEY")
        if not openai_api_key:
            raise ValueError("OPENAI_API_KEY environment variable is required")
        
        # Keep AsyncOpenAI for fallback compatibility
        self.openai_client = AsyncOpenAI(api_key=openai_api_key)
        
        # Initialize LangChain client for better tracing
        self.llm = ChatOpenAI(
            model="gpt-4o-mini",
            temperature=0.3,
            api_key=openai_api_key,
            tags=["query-agent", "abar-chatbot"]
        )
        
        # Rate limiting settings (configurable via environment variables)
        self.last_request_time = 0
        self.min_request_interval = float(os.getenv("OPENAI_MIN_REQUEST_INTERVAL", "0.5"))  # Default 500ms between requests
        self.max_retries = int(os.getenv("OPENAI_MAX_RETRIES", "3"))  # Default 3 retries
        self.base_delay = float(os.getenv("OPENAI_BASE_DELAY", "1"))  # Default 1 second base delay
        
        # Define available functions for the LLM
        self.available_functions = {
            "get_all_cities": lambda user_language='ar': self.get_all_cities(user_language),
            "get_brands_by_city_name": lambda city_name, user_language='ar': self.get_brands_by_city_name(city_name, user_language),
            "get_products_by_brand_and_city_name": lambda brand_name, city_name, user_language='ar': self.get_products_by_brand_and_city_name(brand_name, city_name, user_language),
            "search_cities": self.search_cities,
            "search_brands_in_city": self.search_brands_in_city,
            "get_cheapest_products_by_city_name": self.get_cheapest_products_by_city_name
        }
        
        # Classification prompts for message relevance
        self.classification_prompt_ar = """Ø£Ù†Øª Ù…ØµÙ†Ù Ø±Ø³Ø§Ø¦Ù„ Ø°ÙƒÙŠ Ù„Ø´Ø±ÙƒØ© ØªÙˆØµÙŠÙ„ Ø§Ù„Ù…ÙŠØ§Ù‡. Ù…Ù‡Ù…ØªÙƒ ØªØ­Ø¯ÙŠØ¯ Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ø´Ø±ÙƒØ© Ø£Ù… Ù„Ø§.

        Ø³ÙŠØªÙ… ØªÙ‚Ø¯ÙŠÙ…:
        1. ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ø­Ø¯ÙŠØ« (Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªÙˆÙØ±Ø§Ù‹)
        2. Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø§Ù„ØªÙŠ ØªØ­ØªØ§Ø¬ Ù„Ù„ØªØµÙ†ÙŠÙ

        Ø±Ø§Ø¬Ø¹ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ù„ÙÙ‡Ù… Ø§Ù„Ø³ÙŠØ§Ù‚ Ø¨Ø´ÙƒÙ„ ÙƒØ§Ù…Ù„ Ù‚Ø¨Ù„ ØªØµÙ†ÙŠÙ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©.

        Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„Ø®Ø¯Ù…Ø© ØªØ´Ù…Ù„ ÙÙ‚Ø·:
        âœ… Ø£Ø³Ø¦Ù„Ø© Ø¹Ù† Ø§Ù„Ù…Ø¯Ù† Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ù„ØªÙˆØµÙŠÙ„
        âœ… Ø£Ø³Ø¦Ù„Ø© Ø¹Ù† Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ù„Ù„Ù…ÙŠØ§Ù‡
        âœ… Ø£Ø³Ø¦Ù„Ø© Ø¹Ù† Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙˆØ§Ù„Ø£Ø³Ø¹Ø§Ø±
        âœ… Ø·Ù„Ø¨Ø§Øª Ù…Ø¹Ø±ÙØ© Ø§Ù„ØªÙˆÙØ± ÙÙŠ Ù…Ø¯ÙŠÙ†Ø© Ù…Ø¹ÙŠÙ†Ø© Ø£Ùˆ Ø­ÙŠ Ù…Ø¹ÙŠÙ†
        âœ… Ø£Ø³Ø¦Ù„Ø© Ø¹Ù† ØªÙˆÙØ± Ø§Ù„ØªÙˆØµÙŠÙ„ Ù„Ù„Ù…Ø¯Ù† Ù…Ø«Ù„  ("ÙÙŠÙ‡ ØªÙˆØµÙŠÙ„ Ø¬Ø¯Ø©"ØŒ "Ù‡Ù„ ÙŠÙˆØ¬Ø¯ ØªÙˆØµÙŠÙ„ Ø§Ù„Ø±ÙŠØ§Ø¶"ØŒ "Ù…ØªÙˆÙØ± ØªÙˆØµÙŠÙ„ Ø§Ù„Ø¯Ù…Ø§Ù…")
        âœ… Ø£Ø³Ø¦Ù„Ø© Ø¹Ù† Ø£Ø­Ø¬Ø§Ù… Ø§Ù„Ù…ÙŠØ§Ù‡ ÙˆØ§Ù„Ø¹Ø¨ÙˆØ§Øª
        âœ… Ø£Ø³Ø¦Ù„Ø© Ø¹Ù† Ø§Ù„Ø¯Ø¨Ø§Øª ÙˆØ§Ù„Ù‚ÙˆØ§Ø±ÙŠØ± ÙˆØ§Ù„Ø¬ÙˆØ§Ù„ÙŠÙ† (Ø¹Ø¨ÙˆØ§Øª Ø§Ù„Ù…ÙŠØ§Ù‡ Ø§Ù„ÙƒØ¨ÙŠØ±Ø©)
        âœ… Ø°ÙƒØ± Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ù…Ø«Ù„ (Ù†Ø³ØªÙ„Ù‡ØŒ Ø£ÙƒÙˆØ§ÙÙŠÙ†Ø§ØŒ Ø§Ù„Ø¹ÙŠÙ†ØŒ Ø§Ù„Ù‚ØµÙŠÙ…ØŒ Ø§Ù„Ù…Ø±Ø§Ø¹ÙŠØŒ Ø­Ù„ÙˆÙ‡ØŒ ÙˆØºÙŠØ±Ù‡Ø§)
        âœ… Ø£ÙŠ Ø°ÙƒØ± Ù„Ù€ "Ù…ÙŠØ§Ù‡" Ù…Ø¹ Ø£Ø­Ø¬Ø§Ù… Ø£Ùˆ Ø£ÙˆØµØ§Ù Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª (Ù…Ø«Ù„ "Ù…ÙŠØ§Ù‡ Ø­Ù„ÙˆÙ‡ 200 Ù…Ù„", "Ù…ÙŠØ§Ù‡ Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯", "Ù…ÙŠØ§Ù‡ ØµØºÙŠØ±Ø©")
        âœ… Ø£Ø³Ø¦Ù„Ø© Ø§Ù„ØªÙˆÙØ± Ù…Ø¹ Ø°ÙƒØ± "Ù…ÙŠØ§Ù‡" ("Ø¹Ù†Ø¯ÙƒÙ… Ù…ÙŠØ§Ù‡", "ÙŠÙˆØ¬Ø¯ Ù…ÙŠØ§Ù‡", "Ù…ØªÙˆÙØ± Ù…ÙŠØ§Ù‡")
        âœ… ÙˆØµÙ Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ù…ÙŠØ§Ù‡ ("Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯", "Ø§Ù„Ø­Ø¬Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯", "Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯", Ø£ÙŠ ÙˆØµÙ Ù…Ø¹ ÙƒÙ„Ù…Ø© "Ù…ÙŠØ§Ù‡")
        âœ… Ø§Ù„Ø±Ø¯ Ø¨Ù€ "Ù†Ø¹Ù…" Ø£Ùˆ "Ø£ÙŠ" Ø¹Ù†Ø¯Ù…Ø§ Ù†Ø³Ø£Ù„ Ø¹Ù† Ù…Ù†ØªØ¬ Ù…Ø¹ÙŠÙ† ÙÙŠ Ø³ÙŠØ§Ù‚ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
        âœ… Ø£Ø³Ø¦Ù„Ø© Ø¹Ù† Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ© Ø£Ùˆ Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„Ø£Ø³Ø¹Ø§Ø±
        âœ… Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø·Ù„Ø¨ Ø£Ùˆ Ø§Ù„Ø´Ø±Ø§Ø¡ ("Ø£Ø±ÙŠØ¯ Ø£Ø·Ù„Ø¨"ØŒ "ÙƒÙŠÙ Ø£Ø·Ù„Ø¨"ØŒ "Ø£Ø±ÙŠØ¯ Ø£Ø´ØªØ±ÙŠ"ØŒ "Ø£Ø¨ÙŠ Ø£Ø·Ù„Ø¨")
        âœ… Ø·Ù„Ø¨Ø§Øª ØªÙˆØµÙŠÙ„ Ø§Ù„Ù…ÙŠØ§Ù‡ Ù…Ø¹ Ø°ÙƒØ± Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© ("Ø£Ø±ÙŠØ¯ ØªÙˆØµÙŠÙ„ Ù…ÙŠØ§Ù‡ Ù†Ø³ØªÙ„Ù‡"ØŒ "Ø§Ø±ØºØ¨ Ø¨ØªÙˆØµÙŠÙ„ Ù…ÙŠØ§Ù‡ Ø±Ø§ÙŠÙ†")
        âœ… Ø§Ù„Ø±Ø¯ÙˆØ¯ Ø¹Ù„Ù‰ Ø£Ø³Ø¦Ù„Ø© Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„Ù…ÙŠØ§Ù‡ ÙˆØ§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© ÙÙŠ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©

        ğŸš¨ ØªÙ…ÙŠÙŠØ² Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹ - Ø£Ø³Ø¦Ù„Ø© Ø§Ù„ØªÙˆØµÙŠÙ„ Ù‚Ø¨Ù„ ÙˆØ¨Ø¹Ø¯ Ø§Ù„Ø·Ù„Ø¨:
        âœ… Ø£Ø³Ø¦Ù„Ø© Ø§Ù„ØªÙˆØµÙŠÙ„ Ù‚Ø¨Ù„ Ø§Ù„Ø·Ù„Ø¨ (Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„Ø®Ø¯Ù…Ø©):
        - "ÙÙŠÙ‡ ØªÙˆØµÙŠÙ„ Ù„Ù…Ø¯ÙŠÙ†ØªÙŠØŸ"ØŒ "ØªØµÙ„ÙˆÙ† Ø§Ù„Ø±ÙŠØ§Ø¶ØŸ"ØŒ "Ù‡Ù„ ÙŠÙˆØ¬Ø¯ ØªÙˆØµÙŠÙ„ Ø¬Ø¯Ø©ØŸ"
        - "ØªÙ‚Ø¯Ø±ÙˆÙ† ØªÙˆØµÙ„ÙˆÙ† Ù„Ø­ÙŠ ÙƒØ°Ø§ØŸ"ØŒ "Ø§Ù„ØªÙˆØµÙŠÙ„ Ù…ØªÙˆÙØ± ÙÙŠ Ù…Ù†Ø·Ù‚ØªÙ†Ø§ØŸ"
        - Ø£ÙŠ Ø³Ø¤Ø§Ù„ Ø¹Ù† Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ø£Ùˆ ØªÙˆÙØ± Ø§Ù„ØªÙˆØµÙŠÙ„ Ù„Ù…ÙƒØ§Ù† Ù…Ø¹ÙŠÙ† Ù‚Ø¨Ù„ ØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ø·Ù„Ø¨

        âŒ Ø£Ø³Ø¦Ù„Ø© Ø§Ù„ØªÙˆØµÙŠÙ„ Ø¨Ø¹Ø¯ Ø§Ù„Ø·Ù„Ø¨ (ØºÙŠØ± Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„Ø®Ø¯Ù…Ø©):
        - "Ù…ØªÙ‰ ÙŠÙˆØµÙ„ Ø§Ù„Ø·Ù„Ø¨ØŸ"ØŒ "ÙˆÙŠÙ† Ø§Ù„Ù…Ù†Ø¯ÙˆØ¨ØŸ"ØŒ "Ø§Ù„Ø·Ù„Ø¨ Ø§ØªØ£Ø®Ø±"
        - "Ù…ØªÙ‰ ÙŠØ¬ÙŠ Ø§Ù„Ù…Ù†Ø¯ÙˆØ¨ØŸ"ØŒ "ÙƒÙ… Ø¨Ø§Ù‚ÙŠ Ø¹Ù„Ù‰ ÙˆØµÙˆÙ„ Ø§Ù„Ø·Ù„Ø¨ØŸ"
        - Ø£ÙŠ Ø³Ø¤Ø§Ù„ Ø¹Ù† Ø­Ø§Ù„Ø© Ø£Ùˆ ØªÙˆÙ‚ÙŠØª Ø·Ù„Ø¨ ØªÙ… ØªÙ‚Ø¯ÙŠÙ…Ù‡ Ø¨Ø§Ù„ÙØ¹Ù„

        Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ØºÙŠØ± Ø§Ù„Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„Ø®Ø¯Ù…Ø© ØªØ´Ù…Ù„:
        âŒ Ø§Ù„ØªØ­ÙŠØ§Øª Ø§Ù„Ø¹Ø§Ù…Ø© ("Ø£Ù‡Ù„Ø§Ù‹", "Ù…Ø±Ø­Ø¨Ø§", "Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…", "ØµØ¨Ø§Ø­ Ø§Ù„Ø®ÙŠØ±", "Ù…Ø³Ø§Ø¡ Ø§Ù„Ø®ÙŠØ±")  
        âŒ Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø´ÙƒØ± ÙˆØ§Ù„Ø§Ù…ØªÙ†Ø§Ù† ("Ø´ÙƒØ±Ø§Ù‹", "Ø¬Ø²Ø§Ùƒ Ø§Ù„Ù„Ù‡ Ø®ÙŠØ±", "Ù…Ø´ÙƒÙˆØ±", "Ø§Ù„Ù„Ù‡ ÙŠØ¹Ø·ÙŠÙƒ Ø§Ù„Ø¹Ø§ÙÙŠØ©")
        âŒ Ø§Ù„Ù…ÙˆØ§Ø¶ÙŠØ¹ Ø§Ù„Ø¹Ø§Ù…Ø© ØºÙŠØ± Ø§Ù„Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„Ù…ÙŠØ§Ù‡
        âŒ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø´Ø®ØµÙŠØ©
        âŒ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ÙÙŠ Ù…ÙˆØ§Ø¶ÙŠØ¹ Ø£Ø®Ø±Ù‰
        âŒ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø±ÙˆØ§Ø¨Ø·
        âŒ Ù…Ø´Ø§ÙƒÙ„ Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„Ù…Ù†Ø¯ÙˆØ¨ Ø£Ùˆ Ø§Ù„Ù…Ù†Ø¯ÙˆØ¨ÙŠÙ†
        âŒ Ø´ÙƒØ§ÙˆÙŠ Ù…Ù† Ø§Ù„Ù…Ù†Ø¯ÙˆØ¨ Ø£Ùˆ Ø·Ø§Ù‚Ù… Ø§Ù„ØªÙˆØµÙŠÙ„
        âŒ Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„ØªÙˆØµÙŠÙ„ (ØªØ£Ø®ÙŠØ±ØŒ Ø¹Ø¯Ù… ÙˆØµÙˆÙ„ Ø§Ù„Ø·Ù„Ø¨ØŒ Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„ØªÙˆØµÙŠÙ„)
        âŒ Ø´ÙƒØ§ÙˆÙŠ Ø®Ø¯Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ø£Ùˆ Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ø®Ø¯Ù…Ø©
        âŒ Ø·Ù„Ø¨Ø§Øª Ø¥Ù„ØºØ§Ø¡ Ø£Ùˆ ØªØ¹Ø¯ÙŠÙ„ Ø·Ù„Ø¨Ø§Øª Ù…ÙˆØ¬ÙˆØ¯Ø©
        âŒ Ø§Ø³ØªÙØ³Ø§Ø±Ø§Øª Ø¹Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨ Ø£Ùˆ ØªØªØ¨Ø¹ Ø§Ù„Ø·Ù„Ø¨ Ù„Ø© Ø­Ø§Ù„Ø© Ø§Ù„ØªÙˆØµÙŠÙ„ Ø§Ùˆ Ù…ÙˆØ¹Ø¯ Ø§Ù„ØªÙˆØµÙŠÙ„ 
        âŒ Ø£Ø³Ø¦Ù„Ø© Ø¹Ù† Ù…ÙˆØ§Ø¹ÙŠØ¯ Ø§Ù„ØªÙˆØµÙŠÙ„ Ø£Ùˆ ÙˆÙ‚Øª Ø§Ù„ÙˆØµÙˆÙ„ ("Ù…ØªÙ‰ ÙŠÙˆØµÙ„"ØŒ "ÙƒÙ… ÙŠØ³ØªØºØ±Ù‚ Ø§Ù„ØªÙˆØµÙŠÙ„"ØŒ "Ù…ØªÙ‰ ÙŠØ¬ÙŠ Ø§Ù„Ù…Ù†Ø¯ÙˆØ¨")
        âŒ Ø£Ø³Ø¦Ù„Ø© Ø¹Ù† ÙˆÙ‚Øª ÙˆØµÙˆÙ„ Ø§Ù„Ù…Ù†Ø¯ÙˆØ¨ Ø£Ùˆ Ù…Ø¯Ø© Ø§Ù„ØªÙˆØµÙŠÙ„
        âŒ Ø·Ù„Ø¨Ø§Øª ØªØ¹Ø¯ÙŠÙ„ Ù…ÙˆÙ‚Ø¹ Ø§Ù„ØªÙˆØµÙŠÙ„ Ø£Ùˆ Ø§Ù„Ø¹Ù†ÙˆØ§Ù† ("Ø£Ø¨ØºÙ‰ Ø£Ø¹Ø¯Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹"ØŒ "Ø£Ø±ÙŠØ¯ Ø£ØºÙŠØ± Ø§Ù„Ø¹Ù†ÙˆØ§Ù†"ØŒ "ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…ÙƒØ§Ù†")

        ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø®Ø§ØµØ© ÙˆØµØ§Ø±Ù…Ø©:
        - ÙƒÙ† ØµØ§Ø±Ù… Ø¬Ø¯Ø§Ù‹ ÙÙŠ Ø§Ù„ØªØµÙ†ÙŠÙ - ÙÙ‚Ø· Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø¹Ù† Ø§Ù„Ù…Ø¯Ù† ÙˆØ§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© ÙˆØ§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙˆØ§Ù„Ø£Ø³Ø¹Ø§Ø± ØªØ¹ØªØ¨Ø± Ù…ØªØ¹Ù„Ù‚Ø©
        - ğŸš¨ Ø£ÙŠ Ø±Ø³Ø§Ù„Ø© ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙƒÙ„Ù…Ø© "Ù…ÙŠØ§Ù‡" Ù…Ø¹ ÙˆØµÙ Ù…Ù†ØªØ¬ Ø£Ùˆ Ø­Ø¬Ù… Ø£Ùˆ Ø³Ø¤Ø§Ù„ ØªÙˆÙØ± ØªØ¹ØªØ¨Ø± Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„Ø®Ø¯Ù…Ø©
        - ğŸš¨ Ù…Ø«Ø§Ù„: "Ø¹Ù†Ø¯ÙƒÙ… Ù…ÙŠØ§Ù‡ Ø­Ù„ÙˆÙ‡ Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯ 200 Ù…Ù„" = Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„Ø®Ø¯Ù…Ø© (Ø­ØªÙ‰ Ù„Ùˆ ÙƒØ§Ù†Øª "Ø­Ù„ÙˆÙ‡" ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ© ÙƒØ¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ©)
        - ğŸš¨ Ø£ÙŠ Ø§Ø³Ù… Ù…Ø°ÙƒÙˆØ± Ù…Ø¹ "Ù…ÙŠØ§Ù‡" ÙŠØ¬Ø¨ Ø§Ø¹ØªØ¨Ø§Ø±Ù‡ Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ© Ù…Ø­ØªÙ…Ù„Ø© = Ù…ØªØ¹Ù„Ù‚ Ø¨Ø§Ù„Ø®Ø¯Ù…Ø©
        - Ø£ÙŠ Ø±Ø³Ø§Ù„Ø© ØªØ°ÙƒØ± "Ø§Ù„Ù…Ù†Ø¯ÙˆØ¨" Ø£Ùˆ "Ø§Ù„Ø·Ù„Ø¨ Ù„Ù… ÙŠØµÙ„" Ø£Ùˆ "ØªØ£Ø®Ø±" Ø£Ùˆ "Ù…ØªÙ‰ ÙŠÙˆØµÙ„" Ø£Ùˆ "Ù…ØªÙ‰ ÙŠØ¬ÙŠ" ØªØ¹ØªØ¨Ø± ØºÙŠØ± Ù…ØªØ¹Ù„Ù‚Ø©
        - Ù„ÙƒÙ† Ø·Ù„Ø¨Ø§Øª "ØªÙˆØµÙŠÙ„ Ø§Ù„Ù…ÙŠØ§Ù‡" Ù…Ø¹ Ø°ÙƒØ± Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø£Ùˆ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© ØªØ¹ØªØ¨Ø± Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„Ø®Ø¯Ù…Ø©
        - ğŸš¨ Ø§Ù„ÙØ±Ù‚ Ø§Ù„Ø­Ø§Ø³Ù…: Ø£Ø³Ø¦Ù„Ø© "ÙÙŠÙ‡ ØªÙˆØµÙŠÙ„ØŸ" Ø£Ùˆ "ØªØµÙ„ÙˆÙ† Ù„Ù…Ø¯ÙŠÙ†ØªÙŠØŸ" = Ù…ØªØ¹Ù„Ù‚Ø© (Ù‚Ø¨Ù„ Ø§Ù„Ø·Ù„Ø¨)
        - ğŸš¨ Ù„ÙƒÙ† "Ù…ØªÙ‰ ÙŠÙˆØµÙ„ØŸ" Ø£Ùˆ "ÙˆÙŠÙ† Ø§Ù„Ù…Ù†Ø¯ÙˆØ¨ØŸ" = ØºÙŠØ± Ù…ØªØ¹Ù„Ù‚Ø© (Ø¨Ø¹Ø¯ Ø§Ù„Ø·Ù„Ø¨)
        - Ø¥Ø°Ø§ Ø°ÙƒØ± "Ø§Ù„Ø·Ù„Ø¨" Ø£Ùˆ "Ø§Ù„Ù…Ù†Ø¯ÙˆØ¨" Ø£Ùˆ "Ø§Ù„Ø·Ù„Ø¨ÙŠØ©" ÙÙ‡Ùˆ ÙŠØ³Ø£Ù„ Ø¹Ù† Ø·Ù„Ø¨ Ù…ÙˆØ¬ÙˆØ¯ (ØºÙŠØ± Ù…ØªØ¹Ù„Ù‚)
        - Ø£ÙŠ Ø±Ø³Ø§Ù„Ø© ØªØ·Ù„Ø¨ "ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…ÙˆÙ‚Ø¹" Ø£Ùˆ "ØªØºÙŠÙŠØ± Ø§Ù„Ø¹Ù†ÙˆØ§Ù†" Ø£Ùˆ "Ø£Ø¹Ø¯Ù„ Ø§Ù„Ù…ÙƒØ§Ù†" ØªØ¹ØªØ¨Ø± ØºÙŠØ± Ù…ØªØ¹Ù„Ù‚Ø©
        - Ø£ÙŠ Ø´ÙƒÙˆÙ‰ Ø£Ùˆ Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„Ø®Ø¯Ù…Ø© ØªØ¹ØªØ¨Ø± ØºÙŠØ± Ù…ØªØ¹Ù„Ù‚Ø©
        - Ù„Ø§ ØªØ¹ØªØ¨Ø± Ø§Ù„ØªØ­ÙŠØ§Øª ÙˆØ§Ù„Ø´ÙƒØ± Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„Ø®Ø¯Ù…Ø© Ø­ØªÙ‰ Ù„Ùˆ ÙƒØ§Ù†Øª ÙÙŠ Ø³ÙŠØ§Ù‚ Ù…Ø­Ø§Ø¯Ø«Ø© Ø¹Ù† Ø§Ù„Ù…ÙŠØ§Ù‡
        - Ø§Ø¹ØªØ¨Ø± Ø°ÙƒØ± Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ù„Ù„Ù…ÙŠØ§Ù‡ Ù…ØªØ¹Ù„Ù‚ Ø¨Ø§Ù„Ø®Ø¯Ù…Ø© ÙÙ‚Ø·
        - Ø§Ø¹ØªØ¨Ø± Ø§Ù„Ø±Ø¯ Ø¨Ù€ "Ù†Ø¹Ù…" Ø£Ùˆ "Ø£ÙŠ" Ù…ØªØ¹Ù„Ù‚ Ø¨Ø§Ù„Ø®Ø¯Ù…Ø© Ø¥Ø°Ø§ ÙƒØ§Ù† ÙÙŠ Ø³ÙŠØ§Ù‚ Ù…Ø­Ø§Ø¯Ø«Ø© Ø¹Ù† Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙÙ‚Ø·
        - Ø§Ù†ØªØ¨Ù‡ Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©: Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø¹Ù† Ø§Ù„Ù…ÙŠØ§Ù‡ ÙˆØ§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©ØŒ ÙØ­ØªÙ‰ Ø§Ù„Ø±Ø¯ÙˆØ¯ Ø§Ù„Ø¨Ø³ÙŠØ·Ø© Ù‚Ø¯ ØªÙƒÙˆÙ† Ù…ØªØ¹Ù„Ù‚Ø©

        Ø£Ø¬Ø¨ Ø¨Ù€ "relevant" Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙˆØ§Ù„Ø£Ø³Ø¹Ø§Ø± ÙˆØ§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© ÙˆØ§Ù„Ù…Ø¯Ù† ÙÙ‚Ø·ØŒ Ø£Ùˆ "not_relevant" Ù„Ø£ÙŠ Ø´ÙŠØ¡ Ø¢Ø®Ø±."""

        self.classification_prompt_en = """You are a smart message classifier for a water delivery company. Your task is to determine if a message is related to the company's services or not.

            Service-related messages include ONLY:
            âœ… Questions about available cities for delivery
            âœ… Questions about water brands
            âœ… Questions about products and prices
            âœ… Requests to check availability in specific cities
            âœ… Questions about delivery availability to cities BEFORE placing order ("is there delivery to Jeddah", "delivery available in Riyadh", "do you deliver to Dammam", "can you deliver to our area?")
            âœ… Questions about water sizes and packaging
            âœ… Questions about water gallons, jugs, and large water containers
            âœ… Mentioning brand names like (Nestle, Aquafina, Alain, Qassim, Almarai, Helwa, etc.)
            âœ… Any mention of "water" with product sizes or descriptions ("Helwa water 200ml", "water new design", "small water")
            âœ… Availability questions with "water" ("do you have water", "water available", "any water")
            âœ… Water product descriptions ("new design", "new size", "new type", any description with "water")
            âœ… Replying with "yes" when we ask about a specific product
            âœ… Questions about total prices or price lists
            âœ… Order requests or purchase inquiries ("I want to order", "how to order", "I want to buy")
            âœ… Water delivery requests with brand mentions ("I want Nestle water delivery", "I need Rain water delivery")

            ğŸš¨ CRITICAL DISTINCTION - Pre-Order vs Post-Order Delivery Questions:
            âœ… Pre-Order Delivery Questions (SERVICE-RELATED):
            - "Do you deliver to my city?", "Is delivery available in Riyadh?", "Can you deliver to Jeddah?"
            - "Do you deliver to our neighborhood?", "Is delivery available in our area?"
            - Any question about delivery possibility or availability BEFORE placing an order

            âŒ Post-Order Delivery Questions (NOT SERVICE-RELATED):
            - "When will my order arrive?", "Where is the driver?", "My order is late"
            - "When is the driver coming?", "How long until delivery arrives?"
            - Any question about status or timing of an order that was ALREADY placed

            Non-service-related messages include:
            âŒ General greetings ("hello", "hi", "good morning", "good evening", "how are you")
            âŒ Thank you messages ("thanks", "thank you", "appreciate it", "much obliged")
            âŒ General topics not related to water
            âŒ Personal questions
            âŒ Requests for help with other topics
            âŒ Messages containing links or URLs
            âŒ General delivery service inquiries (without mentioning specific brand or city)
            âŒ Problems related to delivery person/driver
            âŒ Complaints about delivery person or delivery staff
            âŒ Delivery problems (delays, order not arrived, delivery issues)
            âŒ Customer service complaints or service problems
            âŒ Requests to cancel or modify existing orders
            âŒ Inquiries about order status or order tracking
            âŒ Questions about delivery times or arrival times ("when will it arrive", "how long does delivery take", "when will the driver come")
            âŒ Questions about driver arrival time or delivery duration
            âŒ Requests to edit delivery location or address ("I want to change the address", "edit location", "modify delivery address")

            Special strict instructions:
            - Be very strict in classification - only questions about cities, brands, products, and prices count as relevant
            - ğŸš¨ Any message containing "water" with product description or size or availability question counts as service-related
            - ğŸš¨ Example: "do you have Helwa water new design 200ml" = service-related (even if "Helwa" is unknown brand)
            - ğŸš¨ Any name mentioned with "water" should be considered potential brand = service-related
            - Any message mentioning "delivery person", "driver", "order not arrived", "delayed", "when will it arrive", or "how long" is not relevant
            - But water delivery requests with brand or city mentions are service-related
            - ğŸš¨ CRITICAL DIFFERENCE: Questions like "do you deliver?" or "delivery available in my city?" = relevant (before order)
            - ğŸš¨ But "when will it arrive?" or "where is the driver?" = not relevant (after order)
            - Check conversation context: If customer hasn't mentioned placing an order, they're asking about availability (relevant)
            - If they mention "my order", "the driver", or "delivery person" they're asking about existing order (not relevant)
            - Any message requesting to "edit location", "change address", or "modify delivery location" is not relevant
            - Any complaint or service problem is not relevant
            - Do not consider greetings and thanks as service-related even if they appear in water-related conversations
            - Consider mentioning water brand names as service-related only
            - Consider "yes" replies as service-related only if in context of product discussions

            Reply with "relevant" if the message is related to products, prices, brands, and cities only, or "not_relevant" for anything else."""
                    
        # Function definitions for OpenAI function calling
        self.function_definitions = [
            {
                "name": "get_all_cities",
                "description": "Get complete list of all cities we serve with water delivery. Use this when user asks about available cities, locations we serve, or wants to see all cities. Returns language-appropriate city names only (Arabic cities for Arabic conversations, English cities for English conversations).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "user_language": {
                            "type": "string",
                            "description": "Language of the conversation ('ar' for Arabic, 'en' for English). Determines which city names to return.",
                            "enum": ["ar", "en"],
                            "default": "ar"
                        }
                    },
                    "required": []
                }
            },
            {
                "name": "get_brands_by_city_name",
                "description": "STEP 1 in workflow: Get all water brands available in a specific city using city name. This handles fuzzy matching for incomplete or misspelled city names. Use this when customer mentions a city and you want to show available brands. Returns language-appropriate brand names only (Arabic brands for Arabic requests, English brands for English requests).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "city_name": {
                            "type": "string",
                            "description": "Name of the city in Arabic or English (e.g., 'Ø§Ù„Ø±ÙŠØ§Ø¶', 'Riyadh', 'Ø¬Ø¯Ø©', 'Jeddah'). Supports partial matches and fuzzy matching."
                        },
                        "user_language": {
                            "type": "string",
                            "description": "Language of the conversation ('ar' for Arabic, 'en' for English). Determines which brand names to return.",
                            "enum": ["ar", "en"],
                            "default": "ar"
                        }
                    },
                    "required": ["city_name"]
                }
            },
            {
                "name": "get_products_by_brand_and_city_name",
                "description": "STEP 2 in workflow: Get all water products for a specific brand in a specific city using names. This handles fuzzy matching for incomplete or misspelled brand/city names. Use this when customer has specified both a brand and city. Returns language-appropriate product strings with prices and contextual message.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "brand_name": {
                            "type": "string",
                            "description": "Name of the brand in Arabic or English (e.g., 'Ù†Ø³ØªÙ„Ù‡', 'Nestle', 'Ø£ÙƒÙˆØ§ÙÙŠÙ†Ø§', 'Aquafina'). Supports partial matches."
                        },
                        "city_name": {
                            "type": "string",
                            "description": "Name of the city in Arabic or English (e.g., 'Ø§Ù„Ø±ÙŠØ§Ø¶', 'Riyadh', 'Ø¬Ø¯Ø©', 'Jeddah'). Supports partial matches."
                        },
                        "user_language": {
                            "type": "string",
                            "description": "Language of the conversation ('ar' for Arabic, 'en' for English). Determines which product names and format to return.",
                            "enum": ["ar", "en"],
                            "default": "ar"
                        }
                    },
                    "required": ["brand_name", "city_name"]
                }
            },
            {
                "name": "search_cities",
                "description": "Search for cities by name when you need to find cities with fuzzy matching. This helps handle typos or find similar city names when the exact city name is unclear.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "query": {
                            "type": "string",
                            "description": "Search term for city name (Arabic or English)"
                        }
                    },
                    "required": ["query"]
                }
            },
            {
                "name": "search_brands_in_city",
                "description": "Search for brands by name within a specific city only. Use this when customer mentions a brand name that might be incomplete or misspelled and you know their city. This function can also be used to check if a specific brand is available in a city or not - if the brand exists in the city, it will be returned in the results; if not, you'll get an empty result indicating the brand is not available in that city.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "brand_name": {
                            "type": "string",
                            "description": "Brand name to search for (Arabic or English). Supports partial matches and can be used for availability checking."
                        },
                        "city_name": {
                            "type": "string",
                            "description": "City name where to search for brands. This is required - we only search within specific cities."
                        }
                    },
                    "required": ["brand_name", "city_name"]
                }
            },
            {
                "name": "get_cheapest_products_by_city_name",
                "description": "Get the cheapest products in each size/packing for a specific city. Use this when user asks about cheapest prices, cheapest brands, or cheapest water in their city. Shows cheapest product from each brand in different sizes.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "city_name": {
                            "type": "string",
                            "description": "Name of the city in Arabic or English (e.g., 'Ø§Ù„Ø±ÙŠØ§Ø¶', 'Riyadh', 'Ø¬Ø¯Ø©', 'Jeddah'). Supports partial matches and fuzzy matching."
                        }
                    },
                    "required": ["city_name"]
                }
            }
        ]
    
    async def _rate_limit_delay(self):
        """Ensure minimum time between API requests"""
        current_time = time.time()
        time_since_last = current_time - self.last_request_time
        if time_since_last < self.min_request_interval:
            delay = self.min_request_interval - time_since_last
            await asyncio.sleep(delay)
        self.last_request_time = time.time()
    
    async def _call_openai_with_retry(self, **kwargs):
        """Make OpenAI API call with exponential backoff retry logic"""
        for attempt in range(self.max_retries + 1):
            try:
                # Apply rate limiting
                await self._rate_limit_delay()
                
                # Make the API call
                response = await self.openai_client.chat.completions.create(**kwargs)
                return response
                
            except Exception as e:
                error_str = str(e)
                
                # Handle 429 rate limit errors specifically
                if "429" in error_str or "rate limit" in error_str.lower():
                    if attempt < self.max_retries:
                        # Exponential backoff with jitter
                        delay = (self.base_delay * (2 ** attempt)) + random.uniform(0, 1)
                        logger.warning(f"Rate limit hit, attempt {attempt + 1}/{self.max_retries + 1}. Retrying in {delay:.2f}s...")
                        await asyncio.sleep(delay)
                        continue
                    else:
                        logger.error("Max retries reached for rate limit error")
                        raise Exception("OpenAI rate limit exceeded. Please try again in a few minutes.")
                
                # Handle other errors
                elif attempt < self.max_retries:
                    delay = 1.0 + random.uniform(0, 0.5)  # Small delay for other errors
                    logger.warning(f"API error on attempt {attempt + 1}: {error_str}. Retrying in {delay:.2f}s...")
                    await asyncio.sleep(delay)
                    continue
                else:
                    # Max retries reached, re-raise the error
                    raise e
        
        # This should never be reached, but just in case
        raise Exception("Unexpected error in API retry logic")
    
    async def _call_langchain_llm(self, messages: List, max_tokens: int = 1500, temperature: float = 0.3):
        """Make LangChain LLM call for better tracing in LangSmith"""
        try:
            # Apply rate limiting (same as before)
            await self._rate_limit_delay()
            
            # Convert dict messages to LangChain message objects if needed
            langchain_messages = []
            for msg in messages:
                if isinstance(msg, dict):
                    if msg["role"] == "system":
                        langchain_messages.append(SystemMessage(content=msg["content"]))
                    elif msg["role"] == "user":
                        langchain_messages.append(HumanMessage(content=msg["content"]))
                    elif msg["role"] == "assistant":
                        langchain_messages.append(AIMessage(content=msg["content"]))
                else:
                    # Already a LangChain message object
                    langchain_messages.append(msg)
            
            # Create a temporary LLM with specific parameters for this call
            temp_llm = self.llm.bind(max_tokens=max_tokens, temperature=temperature)
            
            # Make the call (this will be traced in LangSmith)
            response = await temp_llm.ainvoke(langchain_messages)
            
            # Return in format similar to OpenAI response for compatibility
            return {"content": response.content}
            
        except Exception as e:
            logger.error(f"Error in LangChain LLM call: {str(e)}")
            raise e
    
    def _get_db_session(self):
        """Get database session"""
        from database.db_utils import SessionLocal
        return SessionLocal()
    
    def _clean_brand_name(self, brand_text: str) -> str:
        """Remove water-related prefixes from brand names and apply normalization
        Removes: Ù…ÙŠØ§Ù‡, Ù…ÙˆÙŠØ©, Ù…ÙŠØ§Ø© before brand names
        Applies Arabic text normalization for better matching
        Example: 'Ù…ÙŠØ§Ù‡ ÙˆÙŠ' -> 'ÙˆÙŠ', 'Ù…ÙˆÙŠØ© Ù†Ù‚ÙŠ' -> 'Ù†Ù‚ÙŠ'
        """
        from database.district_utils import DistrictLookup
        
        # Water prefixes to remove (case insensitive)
        water_prefixes = ["Ù…ÙŠØ§Ù‡", "Ù…ÙˆÙŠØ©", "Ù…ÙŠØ§Ø©", "Ù…ÙŠÙ‡", "water"]
        
        # Clean the brand text
        cleaned_text = brand_text.strip()
        
        # Remove water prefixes from the beginning
        for prefix in water_prefixes:
            # Check if text starts with the prefix followed by space
            if cleaned_text.lower().startswith(prefix.lower() + " "):
                cleaned_text = cleaned_text[len(prefix):].strip()
                break
            # Check if text starts with the prefix without space (for concatenated cases)
            elif cleaned_text.lower().startswith(prefix.lower()) and len(cleaned_text) > len(prefix):
                cleaned_text = cleaned_text[len(prefix):].strip()
                break
        
        # Apply normalization for better brand matching
        normalized_text = DistrictLookup.normalize_city_name(cleaned_text)
        
        return normalized_text
    
    async def _verify_city_extraction(self, user_message: str, conversation_history: List[Dict] = None, extracted_city: str = None, extraction_source: str = "message") -> bool:
        """Use ChatGPT to verify if the extracted city/district is correct based on the user's message and FULL conversation history"""
        try:
            print(f"ğŸ” [CITY VERIFICATION] Starting verification for '{extracted_city}' from {extraction_source}")
            
            # Prepare FULL context from conversation history (both user and assistant messages)
            context = ""
            if conversation_history:
                recent_messages = conversation_history[-5:]  # Last 8 messages for better context
                print(f"ğŸ” [CITY VERIFICATION] Using {len(recent_messages)} recent messages for context")
                
                context_lines = []
                for msg in recent_messages:
                    role = msg.get('role', 'unknown')
                    content = msg.get('content', '')
                    if role == 'user':
                        context_lines.append(f"Ø§Ù„Ø¹Ù…ÙŠÙ„: {content}")
                    elif role == 'assistant':
                        context_lines.append(f"Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯: {content}")
                    else:
                        context_lines.append(f"{role}: {content}")
                
                context = "\n".join(context_lines)
                context = f"ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ø­Ø¯ÙŠØ«:\n{context}\n"
                print(f"ğŸ” [CITY VERIFICATION] Context prepared: {len(context)} characters")
            
            # Enhanced verification prompt
            verification_prompt = f"""Ø£Ù†Øª Ø®Ø¨ÙŠØ± ÙÙŠ ÙÙ‡Ù… Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© ÙˆØ§Ø³ØªØ®Ø±Ø§Ø¬ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø¯Ù† ÙˆØ§Ù„Ø£Ø­ÙŠØ§Ø¡. Ù…Ù‡Ù…ØªÙƒ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø£Ùˆ Ø§Ù„Ø­ÙŠ.

{context}
Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ù„Ø¹Ù…ÙŠÙ„: "{user_message}"

Ø§Ø³ØªØ®Ø±Ø¬Ù†Ø§ "{extracted_city}" Ù…Ù† {extraction_source}.

ğŸš¨ Ù‚ÙˆØ§Ø¹Ø¯ Ù…Ù‡Ù…Ø© Ù„Ù„ØªØ­Ù‚Ù‚:
1. ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø°ÙƒØ± Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø£Ùˆ Ø§Ù„Ø­ÙŠ Ø¨ÙˆØ¶ÙˆØ­ ÙÙŠ Ø±Ø³Ø§Ù„ØªÙ‡ Ø£Ùˆ Ø£ÙƒØ¯ Ø¹Ù„ÙŠÙ‡Ø§
2. Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ù‚Ø¯ Ø°ÙƒØ± Ø¹Ø¯Ø© Ù…Ø¯Ù† ÙˆÙ‚Ø§Ù„ Ø§Ù„Ø¹Ù…ÙŠÙ„ "Ù†Ø¹Ù…" Ø£Ùˆ "Ù…ÙˆØ§ÙÙ‚" Ø¨Ø¯ÙˆÙ† ØªØ­Ø¯ÙŠØ¯ Ù…Ø¯ÙŠÙ†Ø© Ù…Ø¹ÙŠÙ†Ø© - Ù‡Ø°Ø§ Ø®Ø·Ø£
3. Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ ÙŠØ³Ø£Ù„ "Ø£ÙŠ Ù…Ø¯ÙŠÙ†Ø© ØªØ±ÙŠØ¯ØŸ" ÙˆØ£Ø¬Ø§Ø¨ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¨Ø´ÙŠØ¡ ØºØ§Ù…Ø¶ - Ù‡Ø°Ø§ Ø®Ø·Ø£
4. ÙÙ‚Ø· Ø¥Ø°Ø§ Ø°ÙƒØ± Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø§Ø³Ù… Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø¨ÙˆØ¶ÙˆØ­ Ø£Ùˆ Ø£ÙƒØ¯ Ø¹Ù„Ù‰ Ù…Ø¯ÙŠÙ†Ø© Ù…Ø¹ÙŠÙ†Ø© - Ù‡Ø°Ø§ ØµØ­ÙŠØ­

Ù‡Ù„ Ø§Ø³ØªØ®Ø±Ø§Ø¬ "{extracted_city}" ØµØ­ÙŠØ­ ÙˆÙ…Ø¨Ø±Ø± Ù…Ù† Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙÙ‚Ø·ØŸ

Ø£Ø¬Ø¨ Ø¨Ù€ "ØµØ­ÙŠØ­" Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø°ÙƒØ± Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø¨ÙˆØ¶ÙˆØ­ØŒ Ø£Ùˆ "Ø®Ø·Ø£" Ø¥Ø°Ø§ Ù„Ù… ÙŠØ°ÙƒØ±Ù‡Ø§ Ø£Ùˆ ÙƒØ§Ù† ØºØ§Ù…Ø¶."""

            print(f"ğŸ” [CITY VERIFICATION] Sending prompt to LLM for verification")
            
            # Call LangChain for verification
            response = await self._call_langchain_llm(
                messages=[
                    {"role": "system", "content": "Ø£Ù†Øª Ø®Ø¨ÙŠØ± ÙÙŠ ÙÙ‡Ù… Ø§Ù„Ù†ØµÙˆØµ ÙˆØ§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬ØºØ±Ø§ÙÙŠØ©. ÙƒÙ† Ø¯Ù‚ÙŠÙ‚Ø§Ù‹ Ø¬Ø¯Ø§Ù‹ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚."},
                    {"role": "user", "content": verification_prompt}
                ],
                temperature=0.1,
                max_tokens=20
            )
            
            verification_result = response["content"].strip().lower()
            is_correct = "ØµØ­ÙŠØ­" in verification_result
            
            print(f"ğŸ” [CITY VERIFICATION] Raw LLM response: '{response['content']}'")
            print(f"ğŸ” [CITY VERIFICATION] Verification result for '{extracted_city}': {verification_result} -> {'âœ… APPROVED' if is_correct else 'âŒ REJECTED'}")
            
            if not is_correct:
                print(f"ğŸš¨ [CITY VERIFICATION] City '{extracted_city}' was REJECTED - user did not explicitly mention this city")
            else:
                print(f"âœ… [CITY VERIFICATION] City '{extracted_city}' was APPROVED - user explicitly mentioned this city")
            
            return is_correct
            
        except Exception as e:
            print(f"ğŸ” [CITY VERIFICATION] ERROR in verification: {str(e)}")
            logger.error(f"Error in city extraction verification: {str(e)}")
            # On error, default to rejecting the extraction for safety
            print(f"ğŸš¨ [CITY VERIFICATION] Defaulting to REJECT due to error for safety")
            return False

    async def _extract_city_from_context(self, user_message: str, conversation_history: List[Dict] = None) -> Optional[Dict[str, Any]]:
        """Extract city information from current message and conversation history with AI verification
        Priority: 1) City in last message, 2) District in last message, 3) City in history (last 5 messages), 4) District in history (last 5 messages)"""
        try:
            
            db = self._get_db_session()
            try:
                all_cities = data_api.get_all_cities(db)
                
                # PRIORITY 1: Check for city in last message (current user message)
                if user_message:
                    # Normalize user message for better matching
                    normalized_user_message = district_lookup.normalize_city_name(user_message)
                    current_content = normalized_user_message.lower()
                    
                    for city in all_cities:
                        # Normalize both Arabic and English city names
                        city_name_ar = district_lookup.normalize_city_name(city.get("name", "")).lower()
                        city_name_en = city.get("name_en", "").lower().strip()
                        
                        # Check normalized Arabic city name
                        if city_name_ar and city_name_ar in current_content:
                            print(f"ğŸ™ï¸ QueryAgent: Found normalized city '{city['name']}' in last message")
                            print(f"   Original: '{city.get('name', '')}' -> Normalized: '{city_name_ar}'")
                            print(f"   User message normalized: '{normalized_user_message}'")
                            
                            # Verify extraction with ChatGPT
                            is_verified = await self._verify_city_extraction(
                                user_message, conversation_history, 
                                city['name'], "Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©"
                            )
                            
                            if is_verified:
                                return {
                                    "city_id": city["id"],
                                    "city_name": city["name"],
                                    "city_name_en": city["name_en"],
                                    "found_in": "current_message_city"
                                }
                        # Check English city name (no normalization needed for English)
                        elif city_name_en and city_name_en in user_message.lower():
                            print(f"ğŸ™ï¸ QueryAgent: Found direct city '{city['name']}' (English) in last message")
                            
                            # Verify extraction with ChatGPT
                            is_verified = await self._verify_city_extraction(
                                user_message, conversation_history, 
                                city['name'], "Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©"
                            )
                            
                            if is_verified:
                                return {
                                    "city_id": city["id"],
                                    "city_name": city["name"],
                                    "city_name_en": city["name_en"],
                                    "found_in": "current_message_city"
                                }
                
                # PRIORITY 2: Check for district in last message (current user message) - COMMENTED OUT
                # if user_message:
                #     district_match = district_lookup.find_district_in_message(user_message, db)
                #     print(f"ğŸ˜ï¸ QueryAgent: District match: {district_match}")
                #     if district_match:
                #         district_name = district_match['district']
                #         city_name = district_match['city']
                #         
                #         print(f"ğŸ˜ï¸ QueryAgent: Found district '{district_name}' -> city '{city_name}' in last message")
                #         
                #         # Verify district extraction with ChatGPT
                #         is_verified = await self._verify_city_extraction(
                #             user_message, conversation_history, 
                #             district_name, "Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© (Ø­ÙŠ)"
                #         )
                #         
                #         if is_verified:
                #             # Find the city details in our cities list (normalize for comparison)
                #             normalized_district_city = district_lookup.normalize_city_name(city_name)
                #             for city in all_cities:
                #                 system_city_name = city.get("name", "").strip()
                #                 normalized_system_city = district_lookup.normalize_city_name(system_city_name)
                #                 
                #                 if normalized_system_city == normalized_district_city:
                #                     print(f"ğŸ¯ QueryAgent: District-to-City mapping from last message:")
                #                     print(f"   ğŸ“ District: '{district_name}' (user is from this district)")
                #                     print(f"   ğŸ™ï¸ Business City: '{city['name']}' (ID: {city['id']}) - THIS will be used for brands/products")
                #                     return {
                #                         "city_id": city["id"],
                #                         "city_name": city["name"],  # â† CITY name (e.g., "Ø§Ù„Ø£Ø­Ø³Ø§Ø¡") - used for business logic
                #                         "city_name_en": city["name_en"],
                #                         "found_in": "current_message_district",
                #                         "district_name": district_name  # â† DISTRICT name (e.g., "Ø§Ù„Ø­Ù…Ø±Ø§Ø¡ Ø§Ù„Ø£ÙˆÙ„") - context only
                #                     }
                
                # PRIORITY 3: Check for city in conversation history
                if conversation_history:
                    for message in reversed(conversation_history[-5:]):  # Check last 5 messages
                        content = message.get("content", "")
                        # Normalize conversation history content for better matching
                        normalized_content = district_lookup.normalize_city_name(content)
                        content_lower = normalized_content.lower()
                        
                        # Check if any city name appears in the message
                        for city in all_cities:
                            # Normalize city names from database
                            city_name_ar = district_lookup.normalize_city_name(city.get("name", "")).lower()
                            city_name_en = city.get("name_en", "").lower().strip()
                            
                            if city_name_ar and city_name_ar in content_lower:
                                print(f"ğŸ™ï¸ QueryAgent: Found normalized city in history '{city['name']}'")
                                print(f"   Original: '{city.get('name', '')}' -> Normalized: '{city_name_ar}'")
                                print(f"   History content normalized: '{normalized_content}'")
                                
                                # Verify extraction with ChatGPT
                                is_verified = await self._verify_city_extraction(
                                    user_message, conversation_history, 
                                    city['name'], "ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©"
                                )
                                
                                if is_verified:
                                    return {
                                        "city_id": city["id"],
                                        "city_name": city["name"],
                                        "city_name_en": city["name_en"],
                                        "found_in": "conversation_history_city"
                                    }
                            elif city_name_en and city_name_en in content.lower():
                                print(f"ğŸ™ï¸ QueryAgent: Found city in history '{city['name']}' (English)")
                                
                                # Verify extraction with ChatGPT
                                is_verified = await self._verify_city_extraction(
                                    user_message, conversation_history, 
                                    city['name'], "ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©"
                                )
                                
                                if is_verified:
                                    return {
                                        "city_id": city["id"],
                                        "city_name": city["name"],
                                        "city_name_en": city["name_en"],
                                        "found_in": "conversation_history_city"
                                    }
                
                # PRIORITY 4: Check for district in conversation history - COMMENTED OUT
                # if conversation_history:
                #     for message in reversed(conversation_history[-5:]):  # Check last 5 messages
                #         content = message.get("content", "")
                #         
                #         district_match = district_lookup.find_district_in_message(content, db)
                #         if district_match:
                #             district_name = district_match['district']
                #             city_name = district_match['city']
                #             
                #             print(f"ğŸ˜ï¸ QueryAgent: Found district in history '{district_name}' -> city '{city_name}'")
                #             
                #             # Verify district extraction with ChatGPT
                #             is_verified = await self._verify_city_extraction(
                #                 user_message, conversation_history, 
                #                 district_name, "ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© (Ø­ÙŠ)"
                #             )
                #             
                #             if is_verified:
                #                 # Find the city details in our cities list (normalize for comparison)
                #                 normalized_district_city = district_lookup.normalize_city_name(city_name)
                #                 for city in all_cities:
                #                     system_city_name = city.get("name", "").strip()
                #                     normalized_system_city = district_lookup.normalize_city_name(system_city_name)
                #                     
                #                     if normalized_system_city == normalized_district_city:
                #                         print(f"ğŸ¯ QueryAgent: District-to-City mapping from history:")
                #                         print(f"   ğŸ“ District: '{district_name}' (user is from this district)")
                #                         print(f"   ğŸ™ï¸ Business City: '{city['name']}' (ID: {city['id']}) - THIS will be used for brands/products")
                #                         return {
                #                             "city_id": city["id"],
                #                             "city_name": city["name"],  # â† CITY name - used for business logic
                #                             "city_name_en": city["name_en"],
                #                             "found_in": "conversation_history_district",
                #                             "district_name": district_name  # â† DISTRICT name - context only
                #                         }

                return None
            finally:
                db.close()
        except Exception as e:
            logger.error(f"Error extracting city from context: {str(e)}")
            return None

    async def _verify_brand_extraction(self, user_message: str, conversation_history: List[Dict] = None, extracted_brand: str = None, extraction_source: str = "message") -> bool:
        """Use ChatGPT to verify if the extracted brand is correct based on the user's message and FULL conversation history"""
        try:
            print(f"ğŸ” [BRAND VERIFICATION] Starting verification for '{extracted_brand}' from {extraction_source}")
            
            # Prepare FULL context from conversation history (both user and assistant messages)
            context = ""
            if conversation_history:
                recent_messages = conversation_history[-5:]  # Last 8 messages for better context
                print(f"ğŸ” [BRAND VERIFICATION] Using {len(recent_messages)} recent messages for context")
                
                context_lines = []
                for msg in recent_messages:
                    role = msg.get('role', 'unknown')
                    content = msg.get('content', '')
                    if role == 'user':
                        context_lines.append(f"Ø§Ù„Ø¹Ù…ÙŠÙ„: {content}")
                    elif role == 'assistant':
                        context_lines.append(f"Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯: {content}")
                    else:
                        context_lines.append(f"{role}: {content}")
                
                context = "\n".join(context_lines)
                context = f"ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ø­Ø¯ÙŠØ«:\n{context}\n"
                print(f"ğŸ” [BRAND VERIFICATION] Context prepared: {len(context)} characters")
            
            # Enhanced verification prompt
            verification_prompt = f"""Ø£Ù†Øª Ø®Ø¨ÙŠØ± ÙÙŠ ÙÙ‡Ù… Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© ÙˆØ§Ø³ØªØ®Ø±Ø§Ø¬ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ù„Ù„Ù…ÙŠØ§Ù‡. Ù…Ù‡Ù…ØªÙƒ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©.

{context}
Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ù„Ø¹Ù…ÙŠÙ„: "{user_message}"

Ø§Ø³ØªØ®Ø±Ø¬Ù†Ø§ Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ© "{extracted_brand}" Ù…Ù† {extraction_source}.

ğŸš¨ Ù‚ÙˆØ§Ø¹Ø¯ Ù…Ù‡Ù…Ø© Ù„Ù„ØªØ­Ù‚Ù‚:
1. ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø°ÙƒØ± Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø¨ÙˆØ¶ÙˆØ­ ÙÙŠ Ø±Ø³Ø§Ù„ØªÙ‡ Ø£Ùˆ Ø£ÙƒØ¯ Ø¹Ù„ÙŠÙ‡Ø§ ØªØ­Ø¯ÙŠØ¯Ø§Ù‹
2. Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ù‚Ø¯ Ø°ÙƒØ± Ø¹Ø¯Ø© Ø¹Ù„Ø§Ù…Ø§Øª ØªØ¬Ø§Ø±ÙŠØ© ÙˆÙ‚Ø§Ù„ Ø§Ù„Ø¹Ù…ÙŠÙ„ "Ù†Ø¹Ù…" Ø£Ùˆ "Ù…ÙˆØ§ÙÙ‚" Ø¨Ø¯ÙˆÙ† ØªØ­Ø¯ÙŠØ¯ Ø¹Ù„Ø§Ù…Ø© Ù…Ø¹ÙŠÙ†Ø© - Ù‡Ø°Ø§ Ø®Ø·Ø£
3. Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ ÙŠØ³Ø£Ù„ "Ø£ÙŠ Ø¹Ù„Ø§Ù…Ø© ØªØ±ÙŠØ¯ØŸ" ÙˆØ£Ø¬Ø§Ø¨ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¨Ø´ÙŠØ¡ ØºØ§Ù…Ø¶ - Ù‡Ø°Ø§ Ø®Ø·Ø£  
4. ÙÙ‚Ø· Ø¥Ø°Ø§ Ø°ÙƒØ± Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø§Ø³Ù… Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø¨ÙˆØ¶ÙˆØ­ Ø£Ùˆ Ø£ÙƒØ¯ Ø¹Ù„Ù‰ Ø¹Ù„Ø§Ù…Ø© Ù…Ø¹ÙŠÙ†Ø© - Ù‡Ø°Ø§ ØµØ­ÙŠØ­
5. Ù„Ø§ ØªÙ‚Ø¨Ù„ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø§Ù„ØªÙŠ Ø°ÙƒØ±Ù‡Ø§ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ ÙÙ‚Ø· ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª

Ù‡Ù„ Ø§Ø³ØªØ®Ø±Ø§Ø¬ "{extracted_brand}" ØµØ­ÙŠØ­ ÙˆÙ…Ø¨Ø±Ø± Ù…Ù† Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙÙ‚Ø·ØŸ

Ø£Ø¬Ø¨ Ø¨Ù€ "ØµØ­ÙŠØ­" Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø°ÙƒØ± Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø¨ÙˆØ¶ÙˆØ­ØŒ Ø£Ùˆ "Ø®Ø·Ø£" Ø¥Ø°Ø§ Ù„Ù… ÙŠØ°ÙƒØ±Ù‡Ø§ Ø£Ùˆ ÙƒØ§Ù† ØºØ§Ù…Ø¶."""

            print(f"ğŸ” [BRAND VERIFICATION] Sending prompt to LLM for verification")
            
            # Call LangChain for verification
            response = await self._call_langchain_llm(
                messages=[
                    {"role": "system", "content": "Ø£Ù†Øª Ø®Ø¨ÙŠØ± ÙÙŠ ÙÙ‡Ù… Ø§Ù„Ù†ØµÙˆØµ ÙˆØ§Ø³ØªØ®Ø±Ø§Ø¬ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©. ÙƒÙ† Ø¯Ù‚ÙŠÙ‚Ø§Ù‹ Ø¬Ø¯Ø§Ù‹ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚."},
                    {"role": "user", "content": verification_prompt}
                ],
                temperature=0.1,
                max_tokens=20
            )
            
            verification_result = response["content"].strip().lower()
            is_correct = "ØµØ­ÙŠØ­" in verification_result
            
            print(f"ğŸ” [BRAND VERIFICATION] Raw LLM response: '{response['content']}'")
            print(f"ğŸ” [BRAND VERIFICATION] Verification result for '{extracted_brand}': {verification_result} -> {'âœ… APPROVED' if is_correct else 'âŒ REJECTED'}")
            
            if not is_correct:
                print(f"ğŸš¨ [BRAND VERIFICATION] Brand '{extracted_brand}' was REJECTED - user did not explicitly mention this brand")
            else:
                print(f"âœ… [BRAND VERIFICATION] Brand '{extracted_brand}' was APPROVED - user explicitly mentioned this brand")
            
            return is_correct
            
        except Exception as e:
            print(f"ğŸ” [BRAND VERIFICATION] ERROR in verification: {str(e)}")
            logger.error(f"Error in brand extraction verification: {str(e)}")
            # On error, default to rejecting the extraction for safety
            print(f"ğŸš¨ [BRAND VERIFICATION] Defaulting to REJECT due to error for safety")
            return False

    async def _extract_brand_from_context(self, user_message: str, conversation_history: List[Dict] = None, city_name: str = None) -> Optional[Dict[str, Any]]:
        """Extract brand information from current message and conversation history with AI verification and improved matching
        IMPORTANT: Only returns brands if city_name is provided (city must be known first)
        IMPORTANT: Ignores size terms like Ø§Ø¨Ùˆ Ø±Ø¨Ø¹, Ø§Ø¨Ùˆ Ù†Øµ, Ø§Ø¨Ùˆ Ø±ÙŠØ§Ù„ as they are NOT brand names
        IMPORTANT: Removes water prefixes like Ù…ÙŠØ§Ù‡, Ù…ÙˆÙŠØ©, Ù…ÙŠØ§Ø© before brand names
        ENHANCED: Searches for identical brand after normalizing, then partial matching
        Priority: 1) Brand in current message (exact â†’ partial), 2) Brand in conversation history (last 5 messages)
        """
        # Do not extract brands without knowing the city first
        if not city_name:
            return None
        
        # Size terms that should NEVER be treated as brand names
        size_terms = ["Ø§Ø¨Ùˆ Ø±Ø¨Ø¹", "Ø§Ø¨Ùˆ Ù†Øµ", "Ø§Ø¨Ùˆ Ø±ÙŠØ§Ù„", "Ø§Ø¨Ùˆ Ø±ÙŠØ§Ù„ÙŠÙ†"]
        
        # Check if the message only contains size terms - if so, don't extract any brand
        message_lower = user_message.lower()
        if any(size_term in message_lower for size_term in size_terms) and not any(brand_indicator in message_lower for brand_indicator in ["Ù†Ø³ØªÙ„Ù‡", "Ø£ÙƒÙˆØ§ÙÙŠÙ†Ø§", "Ø§Ù„Ø¹ÙŠÙ†", "Ø§Ù„Ù‚ØµÙŠÙ…", "Ø§Ù„Ù…Ø±Ø§Ø¹ÙŠ"]):
            return None
            
        try:
            db = self._get_db_session()
            try:
                # Get brands only for the specific city using city name
                brands = data_api.get_brands_by_city_name(db, city_name)
                
                # PRIORITY 1: Check current user message first - EXACT MATCH
                if user_message:
                    # Clean the user message by removing water prefixes
                    cleaned_message = self._clean_brand_name(user_message)
                    current_content = cleaned_message.lower()
                    
                    # First try exact matching after normalization
                    for brand in brands:
                        # Normalize brand title for better matching
                        brand_title_normalized = self._clean_brand_name(brand.get("title", "")).lower().strip()
                        
                        if brand_title_normalized and brand_title_normalized == current_content:
                            print(f"ğŸ¯ Brand exact match found:")
                            print(f"   Original brand: '{brand.get('title', '')}'")
                            print(f"   Normalized brand: '{brand_title_normalized}'")
                            print(f"   User message cleaned: '{current_content}'")
                            
                            # Verify extraction with ChatGPT
                            is_verified = await self._verify_brand_extraction(
                                user_message, conversation_history,
                                brand["title"], "Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© (Ù…Ø·Ø§Ø¨Ù‚Ø© ØªØ§Ù…Ø©)"
                            )
                            
                            if is_verified:
                                return {
                                    "brand_title": brand["title"],
                                    "found_in": "current_message"
                                }
                    
                    # If no exact match, try partial matching
                    for brand in brands:
                        # Normalize brand title for better matching
                        brand_title_normalized = self._clean_brand_name(brand.get("title", "")).lower()
                        
                        if brand_title_normalized and (brand_title_normalized in current_content or current_content in brand_title_normalized):
                            print(f"ğŸ” Brand partial match found:")
                            print(f"   Original brand: '{brand.get('title', '')}'")
                            print(f"   Normalized brand: '{brand_title_normalized}'")
                            print(f"   User message cleaned: '{current_content}'")
                            
                            # Verify extraction with ChatGPT
                            is_verified = await self._verify_brand_extraction(
                                user_message, conversation_history,
                                brand["title"], "Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© (Ù…Ø·Ø§Ø¨Ù‚Ø© Ø¬Ø²Ø¦ÙŠØ©)"
                            )
                            
                            if is_verified:
                                return {
                                    "brand_title": brand["title"],
                                    "found_in": "current_message"
                                }
                
                # PRIORITY 2: Check conversation history if no brand in current message
                if conversation_history:
                    for message in reversed(conversation_history[-5:]):  # Check last 5 messages
                        content = message.get("content", "")
                        # Normalize conversation history content for better brand matching
                        normalized_content = self._clean_brand_name(content).lower()
                        
                        # First try exact matching with normalized content
                        for brand in brands:
                            # Normalize brand title for better matching
                            brand_title_normalized = self._clean_brand_name(brand.get("title", "")).lower().strip()
                            
                            if brand_title_normalized and brand_title_normalized in normalized_content:
                                print(f"ğŸ” Brand found in conversation history:")
                                print(f"   Original brand: '{brand.get('title', '')}'")
                                print(f"   Normalized brand: '{brand_title_normalized}'")
                                print(f"   History content normalized: '{normalized_content}'")
                                
                                # Verify extraction with ChatGPT
                                is_verified = await self._verify_brand_extraction(
                                    user_message, conversation_history,
                                    brand["title"], "ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©"
                                )
                                
                                if is_verified:
                                    return {
                                        "brand_title": brand["title"],
                                        "found_in": "conversation_history"
                                    }
                
                return None
            finally:
                db.close()
        except Exception as e:
            logger.error(f"Error extracting brand from context: {str(e)}")
            return None

    def _check_for_yes_response(self, user_message: str, conversation_history: List[Dict] = None) -> bool:
        """Check if user is responding with yes to a previous product question"""
        if not conversation_history:
            return False
        
        # Check if current message is a yes response
        yes_words = ["Ù†Ø¹Ù…", "Ø£ÙŠ", "Ø£ÙŠÙˆØ©", "Ø§ÙŠ", "yes", "yeah", "yep", "sure", "ok", "okay"]
        user_msg_lower = user_message.lower().strip()
        
        if user_msg_lower in yes_words:
            # Check if the last bot message was asking about a product
            for message in reversed(conversation_history[-5:]):  # Check last 5 messages
                if message.get("role") == "assistant":
                    content = message.get("content", "").lower()
                    # Check if the bot asked about needing a product or mentioned a price
                    if any(phrase in content for phrase in ["ØªØ­ØªØ§Ø¬", "ØªØ±ÙŠØ¯", "Ù‡Ù„ ØªØ±ÙŠØ¯", "Ù‡Ù„ ØªØ­ØªØ§Ø¬", "Ø§Ù„Ø³Ø¹Ø±", "Ø§Ù„Ø«Ù…Ù†", "do you need", "would you like", "price", "cost"]):
                        return True
            return True  # If user says yes in context of water conversation, it's likely relevant
        
        return False

    def _check_for_total_price_question(self, user_message: str) -> bool:
        """Check if user is asking about total prices or price lists"""
        price_keywords = [
            "Ø§Ù„Ø£Ø³Ø¹Ø§Ø±", "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø±", "ÙƒÙ… Ø§Ù„Ø£Ø³Ø¹Ø§Ø±", "Ø§ÙŠØ´ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±",  
            "Ø£Ø³Ø¹Ø§Ø±ÙƒÙ…", "Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±", "ÙƒÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±", "Ø§Ù„Ø§Ø³Ø¹Ø§Ø± ÙƒÙ„Ù‡Ø§",
            "prices", "price list", "all prices", "total prices", "price menu"
        ]
        
        user_msg_lower = user_message.lower()
        return any(keyword.lower() in user_msg_lower for keyword in price_keywords)
    
    def get_all_cities(self, user_language: str = 'ar') -> Dict[str, Any]:
        """Get complete list of all cities we serve
        Returns language-specific city names with contextual message
        """
        try:
            db = self._get_db_session()
            try:
                cities = data_api.get_all_cities(db)
                
                # Filter cities to include only language-appropriate names
                filtered_cities = []
                for city in cities:
                    if user_language == 'ar':
                        # Arabic conversation - return Arabic city names
                        if city.get("name"):  # Only include cities with Arabic names
                            filtered_cities.append(city["name"])
                    else:
                        # English conversation - return English city names, fallback to Arabic
                        city_name = city.get("name_en", "") or city.get("name", "")
                        if city_name:  # Only include cities with names
                            filtered_cities.append(city_name)
                
                # Remove duplicates and sort
                filtered_cities = sorted(list(set(filtered_cities)))
                
                # Create response message
                if user_language == 'ar':
                    response_message = " Ù‡Ø°Ù‡ Ù‡ÙŠ Ø§Ù„Ù…Ø¯Ù† Ø§Ù„ØªÙŠ Ù†Ø®Ø¯Ù…Ù‡Ø§ ÙˆÙ†ÙˆØµÙ„ Ù„Ù‡Ø§ : "
                else:
                    response_message = "These are the cities we serve:"
                
                return {
                    "success": True, 
                    "data": filtered_cities,  # Simple list of city names in appropriate language
                    "language": user_language,
                    "response_message": response_message,
                    "total_cities": len(filtered_cities)
                }
            finally:
                db.close()
        except Exception as e:
            logger.error(f"Error fetching cities: {str(e)}")
            return {"error": f"Failed to get cities: {str(e)}"}
    
    def get_brands_by_city_name(self, city_name: str, user_language: str = 'ar') -> Dict[str, Any]:
        """Get brands available in a specific city using city name with fuzzy matching
        Returns language-specific brand names and city information in response message
        """
        from utils.language_utils import language_handler
        
        try:
            # Use the conversation language instead of detecting from city name
            detected_language = user_language
            print(f"ğŸŒ Using conversation language '{detected_language}' for city '{city_name}'")
            
            db = self._get_db_session()
            try:
                brands = data_api.get_brands_by_city_name(db, city_name)
                if not brands:
                    return {
                        "success": False,
                        "error": f"Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ø§ Ù†Ù‚Ø¯Ù… Ø®Ø¯Ù…Ø© Ø§Ù„ØªÙˆØµÙŠÙ„ Ù„Ù…Ø¯ÙŠÙ†Ø© {city_name} Ø­Ø§Ù„ÙŠØ§Ù‹",
                        "original_input": city_name,
                        "show_app_links": False
                    }
                
                # Extract city information (same for all brands)
                city_ar = brands[0]["city_name"] if brands else city_name
                city_en = brands[0].get("city_name_en", "") if brands else ""
                
                # Filter brands to include only language-appropriate titles
                filtered_brands = []
                for brand in brands:
                    if detected_language == 'ar':
                        # Arabic request - return only Arabic brand names
                        if brand.get("title"):  # Only include brands with Arabic titles
                            filtered_brands.append(brand["title"])
                    else:
                        # English request - return only English brand names, fallback to Arabic
                        brand_name = brand.get("title_en", "") or brand.get("title", "")
                        if brand_name:  # Only include brands with names
                            filtered_brands.append(brand_name)
                
                # Remove duplicates and sort
                filtered_brands = sorted(list(set(filtered_brands)))
                
                # Create response message
                if detected_language == 'ar':
                    response_message = f"Ù‡Ø°Ù‡ Ù‡ÙŠ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø§Ù„Ù…ØªØ§Ø­Ø© ÙÙŠ {city_ar}:"
                    city_info = city_ar
                else:
                    city_display = city_en if city_en else city_ar
                    response_message = f"These are the brands available in {city_display}:"
                    city_info = city_display
                
                return {
                    "success": True, 
                    "data": filtered_brands,  # Simple list of brand names in detected language
                    "city_found": city_info,
                    "language": detected_language,
                    "response_message": response_message,
                    "total_brands": len(filtered_brands)
                }
            finally:
                db.close()
        except Exception as e:
            logger.error(f"Error fetching brands for city {city_name}: {str(e)}")
            return {"error": f"Failed to get brands: {str(e)}"}
    
    def get_products_by_brand_and_city_name(self, brand_name: str, city_name: str, user_language: str = 'ar') -> Dict[str, Any]:
        """Get products for a specific brand in a specific city using names with fuzzy matching
        Returns language-specific product strings with prices and contextual message
        """
        from utils.language_utils import language_handler
        
        try:
            # Use the conversation language instead of detecting from brand/city names
            detected_language = user_language
            print(f"ğŸŒ Using conversation language '{detected_language}' for brand '{brand_name}' in city '{city_name}'")
            
            # Clean the brand name by removing water prefixes
            cleaned_brand_name = self._clean_brand_name(brand_name)
            
            db = self._get_db_session()
            try:
                # Try with cleaned brand name first
                products = data_api.get_products_by_brand_and_city_name(db, cleaned_brand_name, city_name)
                
                # If no results with cleaned name, try original name
                if not products:
                    products = data_api.get_products_by_brand_and_city_name(db, brand_name, city_name)
                if not products:
                    return {
                        "success": False,
                        "error": f"Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© {brand_name} ØºÙŠØ± Ù…ØªÙˆÙØ±Ø© ÙÙŠ Ù…Ø¯ÙŠÙ†Ø© {city_name} Ø­Ø§Ù„ÙŠØ§Ù‹",
                        "original_brand": brand_name,
                        "original_city": city_name
                    }
                
                # Extract brand and city information
                brand_ar = products[0]["brand_title"] if products else brand_name
                brand_en = products[0].get("brand_title_en", "") if products else ""
                city_ar = products[0]["city_name"] if products else city_name
                city_en = products[0].get("city_name_en", "") if products else ""
                
                # Create simple product strings with prices
                filtered_products = []
                for product in products:
                    price = product["product_contract_price"]
                    title = product["product_title"]
                    
                    if detected_language == 'ar':
                        # Arabic format: "Product Title - XX.XX Ø±ÙŠØ§Ù„"
                        product_string = f"{title} - {price} Ø±ÙŠØ§Ù„"
                    else:
                        # English format: "Product Title - XX.XX SAR"
                        product_string = f"{title} - {price} SAR"
                    
                    filtered_products.append(product_string)
                
                # Create response message
                if detected_language == 'ar':
                    response_message = f"Ù…Ù†ØªØ¬Ø§Øª {brand_ar} Ø§Ù„Ù…ØªØ§Ø­Ø© ÙÙŠ {city_ar}:"
                    brand_found = brand_ar
                    city_found = city_ar
                else:
                    brand_display = brand_en if brand_en else brand_ar
                    city_display = city_en if city_en else city_ar
                    response_message = f"{brand_display} products available in {city_display}:"
                    brand_found = brand_display
                    city_found = city_display
                
                return {
                    "success": True, 
                    "data": filtered_products,  # Simple list of product strings with prices
                    "language": detected_language,
                    "response_message": response_message,
                    "brand_found": brand_found,
                    "city_found": city_found,
                    "total_products": len(filtered_products)
                }
            finally:
                db.close()
        except Exception as e:
            logger.error(f"Error fetching products for brand {brand_name} in city {city_name}: {str(e)}")
            return {"error": f"Failed to get products: {str(e)}"}
    
    def search_brands_in_city(self, brand_name: str, city_name: str) -> Dict[str, Any]:
        """Search for brands by name within a specific city only"""
        try:
            # Clean the brand name by removing water prefixes
            cleaned_brand_name = self._clean_brand_name(brand_name)
            
            db = self._get_db_session()
            try:
                # Search with both cleaned and original brand names
                brands = data_api.search_brands_in_city(db, cleaned_brand_name, city_name)
                
                # If no results with cleaned name, try original name
                if not brands:
                    brands = data_api.search_brands_in_city(db, brand_name, city_name)
                
                if not brands:
                    return {
                        "success": False,
                        "error": f"Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© {brand_name} ØºÙŠØ± Ù…ØªÙˆÙØ±Ø© ÙÙŠ Ù…Ø¯ÙŠÙ†Ø© {city_name} Ø­Ø§Ù„ÙŠØ§Ù‹",
                        "original_brand": brand_name,
                        "original_city": city_name
                    }
                
                # Return found brands
                filtered_brands = [
                    {
                        "title": brand["title"],                    # Brand name in Arabic
                        "title_en": brand.get("title_en", ""),     # Brand name in English
                        "image_url": brand.get("image_url", "")    # Brand image
                    }
                    for brand in brands
                ]
                
                return {
                    "success": True, 
                    "data": filtered_brands,
                    "total_brands": len(filtered_brands)
                }
            finally:
                db.close()
        except Exception as e:
            logger.error(f"Error searching brands for {brand_name}: {str(e)}")
            return {"error": f"Failed to search brands: {str(e)}"}
    
    def search_cities(self, query: str) -> Dict[str, Any]:
        """Search cities by name with """
        try:
            db = self._get_db_session()
            try:
                cities = data_api.search_cities(db, query)
                
                if not cities:
                    return {
                        "success": False,
                        "error": f"Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ø§ Ù†Ù‚Ø¯Ù… Ø®Ø¯Ù…Ø© Ø§Ù„ØªÙˆØµÙŠÙ„ Ù„Ù…Ø¯ÙŠÙ†Ø© {query} Ø­Ø§Ù„ÙŠØ§Ù‹",
                        "query": query,
                        "show_app_links": False
                    }
                
                # Filter to return city information with match type for better UX
                filtered_cities = []
                main_riyadh_found = False
                regions_found = []
                
                for city in cities:
                    city_data = {
                        "id": city["id"],
                        "name": city["name"],        # Arabic name
                        "name_en": city.get("name_en", ""),   # English name
                        "match_type": city.get("match_type", "partial")
                    }
                    
                    # Track Riyadh regions for better messaging
                    if city["name"] == "Ø§Ù„Ø±ÙŠØ§Ø¶":
                        main_riyadh_found = True
                    elif city["name"] in ["Ø´Ù…Ø§Ù„ Ø§Ù„Ø±ÙŠØ§Ø¶", "Ø¬Ù†ÙˆØ¨ Ø§Ù„Ø±ÙŠØ§Ø¶", "ØºØ±Ø¨ Ø§Ù„Ø±ÙŠØ§Ø¶", "Ø´Ø±Ù‚ Ø§Ù„Ø±ÙŠØ§Ø¶"]:
                        regions_found.append(city["name"])
                    
                    filtered_cities.append(city_data)
                
                # Add helpful message for Riyadh searches
                message = None
                if main_riyadh_found and regions_found:
                    message = f"ÙˆØ¬Ø¯Øª Ø§Ù„Ø±ÙŠØ§Ø¶ Ùˆ {len(regions_found)} Ù…Ù†Ø§Ø·Ù‚ Ø£Ø®Ø±Ù‰ ÙÙŠ Ø§Ù„Ø±ÙŠØ§Ø¶"
                elif regions_found and not main_riyadh_found:
                    message = f"ÙˆØ¬Ø¯Øª {len(regions_found)} Ù…Ù†Ø·Ù‚Ø© ÙÙŠ Ø§Ù„Ø±ÙŠØ§Ø¶"
                elif len(filtered_cities) > 5:
                    message = f"ÙˆØ¬Ø¯Øª {len(filtered_cities)} Ù…Ø¯ÙŠÙ†Ø© ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ '{query}'"
                
                return {
                    "success": True, 
                    "data": filtered_cities,
                    "count": len(filtered_cities),
                    "query": query,
                    "message": message
                }
                
            finally:
                db.close()
        except Exception as e:
            logger.error(f"Error searching cities: {str(e)}")
            return {"success": False, "error": f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ø¯Ù†: {str(e)}"}
    


    def get_cheapest_products_by_city_name(self, city_name: str) -> Dict[str, Any]:
        """Get cheapest products in each size for a specific city using city name with fuzzy matching"""
        try:
            db = self._get_db_session()
            try:
                result = data_api.get_cheapest_products_by_city_name(db, city_name)
                return result
            finally:
                db.close()
        except Exception as e:
            logger.error(f"Error fetching cheapest products for city {city_name}: {str(e)}")
            return {"error": f"Failed to get cheapest products: {str(e)}"}
    
    async def _classify_message_relevance(self, user_message: str, conversation_history: List[Dict] = None, user_language: str = 'ar') -> bool:
        """
        Use AI to classify if a message is related to water delivery services
        Returns True if relevant, False if not relevant
        """
        try:
            # Quick check for links - auto-reject messages with URLs
            import re
            url_pattern = r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'
            if re.search(url_pattern, user_message):
                logger.info(f"Message contains URL, marking as not relevant: {user_message[:50]}...")
                return False
            
            # Classification will be performed fresh each time for accuracy
            
            # Prepare context from conversation history
            context = ""
            if conversation_history:
                recent_messages = conversation_history[-5:]  # Last 5 messages for context
                context = "\n".join([f"{msg.get('role', 'user')}: {msg.get('content', '')}" for msg in recent_messages])
                context = f"\nRecent conversation context:\n{context}\n"
            
            # Choose classification prompt based on language
            classification_prompt = self.classification_prompt_ar if user_language == 'ar' else self.classification_prompt_en
            
            # Prepare the full prompt
            full_prompt = f"""{classification_prompt}
{context}
Current message to classify: "{user_message}"

Classification:"""
            
            # Call LangChain for classification (will be traced in LangSmith)
            response = await self._call_langchain_llm(
                messages=[
                    {"role": "system", "content": classification_prompt},
                    {"role": "user", "content": f"{context}\nCurrent message: {user_message}"}
                ],
                temperature=0.1,  # Low temperature for consistent classification
                max_tokens=10  # Short response expected
            )
            
            classification_result = response["content"].strip().lower()
            
            # Log the classification
            logger.info(f"Message classification for '{user_message[:50]}...': {classification_result}")
            
            # Determine relevance
            # Fix: Check for exact match to avoid "not_relevant" being treated as relevant
            is_relevant = classification_result == "relevant"
            
            # Return True if relevant, False if not relevant
            return is_relevant
            
        except Exception as e:
            logger.error(f"Error classifying message relevance: {str(e)}")
            # On error, default to relevant to avoid blocking legitimate queries
            return True
    
    async def _validate_response_appropriateness(self, user_message: str, generated_response: str, conversation_history: List[Dict] = None, user_language: str = 'ar') -> Dict[str, Any]:
        """
        Validate if the generated response is appropriate for the user's message.
        
        Args:
            user_message: The original user message
            generated_response: The response generated by the system
            conversation_history: Previous conversation context
            user_language: Language of the conversation
            
        Returns:
            Dict with 'is_appropriate' (bool), 'reason' (str), and 'confidence' (float)
        """
        try:
            # Build conversation context
            conversation_context = ""
            if conversation_history:
                recent_history = conversation_history[-3:]  # Last 3 messages for context
                for i, msg in enumerate(recent_history):
                    role = msg.get('role', 'unknown')
                    content = msg.get('content', '')
                    conversation_context += f"{i+1}. {role}: {content}\n"
            
            if user_language == 'ar':
                validation_prompt = f"""Ø£Ù†Øª Ù…Ù‚ÙŠÙ… ØµØ§Ø±Ù… Ø¬Ø¯Ø§Ù‹ Ù„Ø¬ÙˆØ¯Ø© Ø§Ù„Ø±Ø¯ÙˆØ¯ ÙÙŠ Ø®Ø¯Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ù„Ø´Ø±ÙƒØ© Ø£Ø¨Ø§Ø± Ù„ØªÙˆØµÙŠÙ„ Ø§Ù„Ù…ÙŠØ§Ù‡.

Ù…Ù‡Ù…ØªÙƒ: ØªØ­Ø¯ÙŠØ¯ Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø±Ø¯ Ø§Ù„Ù…ÙÙˆÙ„Ø¯ Ù…Ù†Ø§Ø³Ø¨ ÙˆÙ…ØªØ¹Ù„Ù‚ Ø¨Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø£Ù… Ù„Ø§.

Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¹Ù…ÙŠÙ„: "{user_message}"
Ø§Ù„Ø±Ø¯ Ø§Ù„Ù…ÙÙˆÙ„Ø¯: "{generated_response}"

Ø§Ù„Ø³ÙŠØ§Ù‚ Ø§Ù„Ø³Ø§Ø¨Ù‚ Ù„Ù„Ù…Ø­Ø§Ø¯Ø«Ø© (Ø¢Ø®Ø± 3 Ø±Ø³Ø§Ø¦Ù„):
{conversation_context}

ğŸ“‹ Ù†Ø·Ø§Ù‚ Ø¹Ù…Ù„ ÙˆÙƒÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª - Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹ Ù„ÙÙ‡Ù… Ø§Ù„Ø±Ø¯ÙˆØ¯ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø©:

ğŸ¯ Ù…Ø§ ÙŠØ³ØªØ·ÙŠØ¹ ÙˆÙƒÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª ÙØ¹Ù„Ù‡:
1. âœ… Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¯Ù† Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ù„ØªÙˆØµÙŠÙ„
2. âœ… Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø§Ù„Ù…ØªØ§Ø­Ø© ÙÙŠ ÙƒÙ„ Ù…Ø¯ÙŠÙ†Ø©
3. âœ… Ø¹Ø±Ø¶ Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ù…ÙŠØ§Ù‡ ÙˆØ£Ø³Ø¹Ø§Ø±Ù‡Ø§ Ù„ÙƒÙ„ Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ©
4. âœ… Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¹Ù„Ø§Ù…Ø§Øª ØªØ¬Ø§Ø±ÙŠØ© ÙÙŠ Ù…Ø¯Ù† Ù…Ø­Ø¯Ø¯Ø©
5. âœ… Ø¹Ø±Ø¶ Ø£Ø±Ø®Øµ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙÙŠ Ù…Ø¯ÙŠÙ†Ø© Ù…Ø¹ÙŠÙ†Ø©
6. âœ… Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¹Ù„Ù‰ Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙˆØ§Ù„Ø£Ø³Ø¹Ø§Ø± ÙˆØ§Ù„ØªÙˆÙØ±
7. âœ… Ø·Ø±Ø­ Ø£Ø³Ø¦Ù„Ø© ÙˆØ¯ÙˆØ¯Ø© Ù„Ø¬Ù…Ø¹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª (Ù…Ø¯ÙŠÙ†Ø©ØŒ Ø¹Ù„Ø§Ù…Ø©ØŒ Ù…Ù†ØªØ¬)
8. âœ… ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ù„Ù„ØªØ·Ø¨ÙŠÙ‚/Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù„Ù„Ø·Ù„Ø¨
9. âœ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø§Ø³ØªÙØ³Ø§Ø±Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø© Ø¹Ù† Ø§Ù„Ù…ÙŠØ§Ù‡ ÙˆØ£Ù†ÙˆØ§Ø¹Ù‡Ø§

âŒ Ù…Ø§ Ù„Ø§ ÙŠØ³ØªØ·ÙŠØ¹ ÙˆÙƒÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª ÙØ¹Ù„Ù‡:
1. âŒ Ø£Ø®Ø° Ø·Ù„Ø¨Ø§Øª ÙØ¹Ù„ÙŠØ© Ø£Ùˆ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¯ÙØ¹
2. âŒ ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆØ§Ø¹ÙŠØ¯ Ø§Ù„ØªÙˆØµÙŠÙ„ Ø£Ùˆ Ø§Ù„ØªÙˆØµÙŠÙ„ Ø§Ù„ÙØ¹Ù„ÙŠ
3. âŒ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ù…Ù†Ø¯ÙˆØ¨ÙŠÙ† Ø£Ùˆ Ø§Ù„ØªÙˆØµÙŠÙ„
4. âŒ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© Ø£Ùˆ Ø¥Ù„ØºØ§Ø¤Ù‡Ø§
5. âŒ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø´ÙƒØ§ÙˆÙŠ Ø£Ùˆ Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ø®Ø¯Ù…Ø©
6. âŒ ØªÙ‚Ø¯ÙŠÙ… Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªÙˆØ§ØµÙ„ Ø£Ùˆ Ø§Ù„Ø¹Ù†Ø§ÙˆÙŠÙ†
7. âŒ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø·Ù„Ø¨Ø§Øª ØªØºÙŠÙŠØ± Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹ Ø£Ùˆ Ø§Ù„Ø¹Ù†Ø§ÙˆÙŠÙ†

ğŸ”§ ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„ÙˆÙƒÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª:
- get_all_cities(): Ø¹Ø±Ø¶ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¯Ù†
- get_brands_by_city_name(): Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª ÙÙŠ Ù…Ø¯ÙŠÙ†Ø©
- get_products_by_brand_and_city_name(): Ø¹Ø±Ø¶ Ù…Ù†ØªØ¬Ø§Øª Ø¹Ù„Ø§Ù…Ø© ÙÙŠ Ù…Ø¯ÙŠÙ†Ø©
- search_brands_in_city(): Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¹Ù„Ø§Ù…Ø§Øª ØªØ¬Ø§Ø±ÙŠØ©
- get_cheapest_products_by_city_name(): Ø£Ø±Ø®Øµ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙÙŠ Ù…Ø¯ÙŠÙ†Ø©

ğŸš¨ ÙÙ‡Ù… Ù…Ù†Ø·Ù‚ Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„Ø­Ø§Ø³Ù…:
- Ø§Ù„Ù†Ø¸Ø§Ù… ÙŠØªØ·Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© ÙˆØ§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ù…Ø¹Ø§Ù‹ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙˆØ§Ù„Ø£Ø³Ø¹Ø§Ø±
- Ø¥Ø°Ø§ Ø°ÙƒØ± Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ù„ÙƒÙ† Ù„Ù… ÙŠØ°ÙƒØ± Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© â†’ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¹Ù† Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø¶Ø±ÙˆØ±ÙŠ ÙˆÙ…Ù†Ø§Ø³Ø¨ âœ…
- Ø¥Ø°Ø§ Ø³Ø£Ù„ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ù† Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ù„ÙƒÙ† Ù„Ù… ÙŠØ­Ø¯Ø¯ Ø§Ù„Ø¹Ù„Ø§Ù…Ø©/Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© â†’ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¹Ù† Ø§Ù„Ø§Ø«Ù†ÙŠÙ† Ø¶Ø±ÙˆØ±ÙŠ ÙˆÙ…Ù†Ø§Ø³Ø¨ âœ…
- Ø¥Ø°Ø§ Ø£Ø±Ø§Ø¯ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ø§Ù…Ø© Ù„ÙƒÙ† Ù„Ù… ÙŠØ­Ø¯Ø¯ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© â†’ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¹Ù† Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø¶Ø±ÙˆØ±ÙŠ ÙˆÙ…Ù†Ø§Ø³Ø¨ âœ…
- Ù‡Ø°Ù‡ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ù„ÙŠØ³Øª Ø¹Ø§Ù…Ø© - Ù‡ÙŠ Ø¶Ø±ÙˆØ±ÙŠØ© Ù„ØªÙ‚Ø¯ÙŠÙ… Ø®Ø¯Ù…Ø© Ø¯Ù‚ÙŠÙ‚Ø©

ğŸ”„ ÙÙ‡Ù… ØªØ¯ÙÙ‚ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ù„ØªÙˆØµÙŠÙ„ Ø§Ù„Ù…ÙŠØ§Ù‡ - Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹:
Ø±Ø§Ø¬Ø¹ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø«Ù„Ø§Ø« Ø§Ù„Ø£Ø®ÙŠØ±Ø© Ù„ÙÙ‡Ù… Ø§Ù„Ø³ÙŠØ§Ù‚:

1ï¸âƒ£ Ø¹Ù†Ø¯Ù…Ø§ ÙŠØ­ØªØ§Ø¬ Ø§Ù„Ø¹Ù…ÙŠÙ„ ØªÙˆØµÙŠÙ„ Ù…ÙŠØ§Ù‡ Ø£Ùˆ ÙŠØ³Ø£Ù„ Ø¹Ù† Ø§Ù„Ø£Ø³Ø¹Ø§Ø±/Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª:
   - Ø¥Ø°Ø§ Ù„Ù… Ù†Ø¹Ø±Ù Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© â†’ Ø§Ù„Ø³Ø¤Ø§Ù„ "Ø£ÙŠ Ù…Ø¯ÙŠÙ†Ø© ØªØ±ÙŠØ¯ØŸ" Ù…Ù†Ø§Ø³Ø¨ âœ…
   - Ø¥Ø°Ø§ Ø¹Ø±ÙÙ†Ø§ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© â†’ Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© ÙÙŠ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ù…Ù†Ø§Ø³Ø¨ âœ…
   
2ï¸âƒ£ Ø¥Ø°Ø§ Ø¹Ø±ÙÙ†Ø§ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© ÙˆØ§Ù„Ø¹Ù…ÙŠÙ„ ÙŠØ±ÙŠØ¯ Ø¹Ù„Ø§Ù…Ø© Ù…Ø¹ÙŠÙ†Ø© Ø£Ùˆ ÙŠØ³Ø£Ù„ Ø¹Ù† Ø§Ù„Ø£Ø³Ø¹Ø§Ø±:
   - Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© Ù…Ù†Ø§Ø³Ø¨ âœ…
   - Ø£Ùˆ Ø§Ù„Ø³Ø¤Ø§Ù„ "Ø£ÙŠ Ù…Ø§Ø±ÙƒØ© ØªØ­ØªØ§Ø¬ØŸ" Ø¥Ø°Ø§ Ù„Ù… ÙŠØ­Ø¯Ø¯ Ø§Ù„Ø¹Ù…ÙŠÙ„
   
3ï¸âƒ£ Ø¹Ù†Ø¯Ù…Ø§ ÙŠØ°ÙƒØ± Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ© Ù…Ø¹ÙŠÙ†Ø©:
   - Ø¥Ø°Ø§ Ù„Ù… Ù†Ø¹Ø±Ù Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© â†’ Ø§Ù„Ø³Ø¤Ø§Ù„ "Ø£ÙŠ Ù…Ø¯ÙŠÙ†Ø© Ø£Ù†Øª ÙÙŠÙ‡Ø§ØŸ" Ù…Ù†Ø§Ø³Ø¨ âœ…
   - Ù‡Ø°Ø§ ÙŠØªØ¨Ø¹ Ø§Ù„ØªØ¯ÙÙ‚ Ø§Ù„Ù…Ù†Ø·Ù‚ÙŠ: Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ© Ù…Ø°ÙƒÙˆØ±Ø© â†’ Ù†Ø­ØªØ§Ø¬ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© â†’ Ù†Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
   - Ù…Ø«Ø§Ù„: Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙŠØ³Ø£Ù„ Ø¹Ù† "Ù…ÙŠØ§Ù‡ Ø±Ø§ÙŠÙ†" â†’ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¹Ù† Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© ØµØ­ÙŠØ­ âœ…
   
4ï¸âƒ£ Ø®Ø¯Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ø§Ù„Ù…ÙÙŠØ¯Ø©:
   - Ø¹Ø±Ø¶ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© Ø£ÙØ¶Ù„ Ù…Ù† Ù…Ø¬Ø±Ø¯ Ø§Ù„Ø³Ø¤Ø§Ù„
   - Ù…Ø«Ø§Ù„: Ø¥Ø°Ø§ Ø¹Ø±ÙÙ†Ø§ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© â†’ Ø§Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©
   - Ù…Ø«Ø§Ù„: Ø¥Ø°Ø§ Ø¹Ø±ÙÙ†Ø§ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© â†’ Ø§Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙˆØ§Ù„Ø£Ø³Ø¹Ø§Ø±

Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„ØµØ§Ø±Ù…Ø©:

ğŸ”´ Ø§Ù„Ø±Ø¯ ØºÙŠØ± Ù…Ù†Ø§Ø³Ø¨ Ø¥Ø°Ø§:
- ÙŠØ¬ÙŠØ¨ Ø¹Ù„Ù‰ Ø³Ø¤Ø§Ù„ Ù…Ø®ØªÙ„Ù ØªÙ…Ø§Ù…Ø§Ù‹ Ø¹Ù† Ø³Ø¤Ø§Ù„ Ø§Ù„Ø¹Ù…ÙŠÙ„
- ÙŠØ®Ù„Ø· Ø¨ÙŠÙ† Ø·Ù„Ø¨Ø§Øª Ø§Ù„ØªÙˆØ§ØµÙ„ ÙˆØ£Ø³Ø¦Ù„Ø© Ø§Ù„ÙØ±ÙˆØ¹ 
- ÙŠØ®Ù„Ø· Ø¨ÙŠÙ† Ø£Ø³Ø¦Ù„Ø© Ø§Ù„ØªÙˆØµÙŠÙ„ Ø§Ù„Ø¹Ø§Ù…Ø© ÙˆØ£Ø³Ø¦Ù„Ø© Ø§Ù„ØªÙˆØµÙŠÙ„ Ù„Ù„Ø¨Ø§Ø¨
- ÙŠÙ‚Ø¯Ù… Ù…Ø¹Ù„ÙˆÙ…Ø§Øª ØºÙŠØ± Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø³Ø¤Ø§Ù„ Ø§Ù„Ø¹Ù…ÙŠÙ„
- ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø±ÙˆØ§Ø¨Ø· Ù…ÙƒØ±Ø±Ø© ÙÙŠ Ù†ÙØ³ Ø§Ù„Ø±Ø³Ø§Ù„Ø©
- Ø¹Ø§Ù… Ø¬Ø¯Ø§Ù‹ ÙˆÙ„Ø§ ÙŠØ¬ÙŠØ¨ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„Ù…Ø­Ø¯Ø¯
- ÙŠØ³Ø£Ù„ Ø£Ø³Ø¦Ù„Ø© ØºÙŠØ± Ù…ÙÙŠØ¯Ø© Ù„Ø§ ØªØ³Ø§Ø¹Ø¯ ÙÙŠ ØªØ­Ù‚ÙŠÙ‚ Ø·Ù„Ø¨ Ø§Ù„Ø¹Ù…ÙŠÙ„
- ÙŠØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªÙŠ Ù‚Ø¯Ù…Ù‡Ø§ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¨Ø§Ù„ÙØ¹Ù„

âš ï¸ ØªÙ†Ø¨ÙŠÙ‡: Ù„Ø§ ØªØ±ÙØ¶ Ø§Ù„Ø±Ø¯ÙˆØ¯ Ø§Ù„ØªÙŠ ØªØ¬ÙŠØ¨ Ø¨ØµØ¯Ù‚ Ø¹Ù„Ù‰ ØªÙˆÙØ± Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª!
âš ï¸ Ø­Ø§Ø³Ù…: Ù„Ø§ ØªØ±ÙØ¶ Ø§Ù„Ø±Ø¯ÙˆØ¯ Ø§Ù„ØªÙŠ ØªØ³Ø£Ù„ Ø¹Ù† Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¶Ø±ÙˆØ±ÙŠØ© (Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©/Ø§Ù„Ø¹Ù„Ø§Ù…Ø©) Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„ØªÙ‚Ø¯ÙŠÙ… Ø®Ø¯Ù…Ø© Ø¯Ù‚ÙŠÙ‚Ø©!
ğŸ”§ Ù…Ù†Ø·Ù‚ Ø§Ù„Ø®Ø¯Ù…Ø©: Ø§Ù„Ù†Ø¸Ø§Ù… ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ³Ø£Ù„ Ø¹Ù† Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©/Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø© Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙˆØ§Ù„Ø£Ø³Ø¹Ø§Ø± - Ù‡Ø°Ø§ Ø³Ù„ÙˆÙƒ Ù…Ù†Ø§Ø³Ø¨!

ğŸŸ¢ Ø§Ù„Ø±Ø¯ Ù…Ù†Ø§Ø³Ø¨ Ø¥Ø°Ø§:
- ÙŠØ¬ÙŠØ¨ Ø¨Ø¯Ù‚Ø© Ø¹Ù„Ù‰ Ø³Ø¤Ø§Ù„ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø§Ù„Ù…Ø­Ø¯Ø¯
- ÙŠØ³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØµØ­ÙŠØ­Ø© Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ø³Ø¤Ø§Ù„
- ÙŠØªÙ…Ø§Ø´Ù‰ Ù…Ø¹ Ø³ÙŠØ§Ù‚ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
- ÙŠÙ‚Ø¯Ù… Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ù…ÙŠØ§Ù‡ Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©
- ÙŠØªØ¨Ø¹ Ø§Ù„ØªØ¯ÙÙ‚ Ø§Ù„Ù…Ù†Ø·Ù‚ÙŠ: Ù…Ø¯ÙŠÙ†Ø© â†’ Ø¹Ù„Ø§Ù…Ø§Øª Ù…ØªØ§Ø­Ø© Ø£Ùˆ Ù…Ù†ØªØ¬Ø§Øª Ø£Ùˆ Ø¹Ù„Ø§Ù…Ø© Ù…Ø°ÙƒÙˆØ±Ø© â†’ ÙŠØ³Ø£Ù„ Ø¹Ù† Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© â†’ ÙŠØ¹Ø±Ø¶ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
- ÙŠØ¹Ø±Ø¶ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ù…Ø¬Ø±Ø¯ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¹Ù†Ù‡Ø§
- ÙŠÙ‚Ø¯Ù… Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…ÙÙŠØ¯Ø© Ø­Ø³Ø¨ Ù…Ø§ Ù†Ø¹Ø±ÙÙ‡ Ù…Ù† Ø§Ù„Ø³ÙŠØ§Ù‚
- ÙŠØ¬ÙŠØ¨ Ø¨ØµØ¯Ù‚ Ø¹Ù† ØªÙˆÙØ± Ø£Ùˆ Ø¹Ø¯Ù… ØªÙˆÙØ± Ù…Ù†ØªØ¬ Ù…Ø¹ÙŠÙ† (Ù…Ù‚Ø¨ÙˆÙ„ Ø­ØªÙ‰ Ù„Ùˆ Ù„Ù… ÙŠÙ‚Ø¯Ù… Ø¨Ø¯Ø§Ø¦Ù„)
- ÙŠØ³Ø£Ù„ Ø¹Ù† Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù†Ø§Ù‚ØµØ© Ø§Ù„Ø¶Ø±ÙˆØ±ÙŠØ© Ù„ØªØ­Ù‚ÙŠÙ‚ Ø·Ù„Ø¨ Ø§Ù„Ø¹Ù…ÙŠÙ„:
  â€¢ ÙŠØ³Ø£Ù„ Ø¹Ù† Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø¹Ù†Ø¯Ù…Ø§ ÙŠØ°ÙƒØ± Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ© Ù„ÙƒÙ† Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ© âœ…
  â€¢ ÙŠØ³Ø£Ù„ Ø¹Ù† Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø¹Ù†Ø¯Ù…Ø§ ÙŠØ³Ø£Ù„ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ù† Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª/Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ù„ÙƒÙ† Ø§Ù„Ø¹Ù„Ø§Ù…Ø© ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ© âœ…
  â€¢ ÙŠØ³Ø£Ù„ Ø£Ø³Ø¦Ù„Ø© Ù…ØªØ§Ø¨Ø¹Ø© Ù…ÙÙŠØ¯Ø© Ù„ØªÙ‚Ø¯ÙŠÙ… Ø®Ø¯Ù…Ø© Ø£ÙØ¶Ù„ âœ…

Ø£Ù…Ø«Ù„Ø© Ø¹Ù„Ù‰ Ø£Ø®Ø·Ø§Ø¡ Ø´Ø§Ø¦Ø¹Ø©:
- Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙŠØ³Ø£Ù„ Ø¹Ù† Ø±Ù‚Ù… Ø§Ù„ØªÙˆØ§ØµÙ„ â†’ Ø§Ù„Ø±Ø¯ ÙŠØªÙƒÙ„Ù… Ø¹Ù† Ø§Ù„ÙØ±ÙˆØ¹ âŒ
- Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙŠØ³Ø£Ù„ Ø¹Ù† Ø§Ù„ØªÙˆØµÙŠÙ„ Ø¹Ø§Ù…Ø© â†’ Ø§Ù„Ø±Ø¯ Ø¹Ù† Ø§Ù„ØªÙˆØµÙŠÙ„ Ù„Ù„Ø¨Ø§Ø¨ ÙÙ‚Ø· âŒ 
- Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙŠØ³Ø£Ù„ Ø¹Ù† Ù…Ø§Ø±ÙƒØ© Ù…Ø¹ÙŠÙ†Ø© â†’ Ø±Ø¯ Ø¹Ø§Ù… Ø¹Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø§Ø±ÙƒØ§Øª âŒ

Ø£Ù…Ø«Ù„Ø© Ø¹Ù„Ù‰ Ø±Ø¯ÙˆØ¯ ØµØ­ÙŠØ­Ø© ÙˆÙ…Ù‚Ø¨ÙˆÙ„Ø©:
- Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙŠØ³Ø£Ù„ Ø¹Ù† "Ù…ÙŠØ§Ù‡ Ø§Ù„Ù…Ù†Ù‡Ù„" â†’ "Ù„Ù„Ø£Ø³ÙØŒ Ù…ÙŠØ§Ù‡ Ø§Ù„Ù…Ù†Ù‡Ù„ ØºÙŠØ± Ù…ØªÙˆÙØ±Ø© Ø­Ø§Ù„ÙŠØ§Ù‹" âœ… (Ù…Ù‚Ø¨ÙˆÙ„)
- Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙŠØ³Ø£Ù„ Ø¹Ù† Ø¹Ù„Ø§Ù…Ø© Ù…Ø¹ÙŠÙ†Ø© â†’ "Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© ØºÙŠØ± Ù…ØªØ§Ø­Ø© ÙÙŠ Ø§Ù„Ø±ÙŠØ§Ø¶" âœ… (Ù…Ù‚Ø¨ÙˆÙ„)
- Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙŠØ°ÙƒØ± "Ù…ÙŠØ§Ù‡ Ø±Ø§ÙŠÙ†" â†’ "Ø£ÙŠ Ù…Ø¯ÙŠÙ†Ø© Ø£Ù†Øª ÙÙŠÙ‡Ø§ØŸ Ø±Ø§Ø­ Ø£Ø¹Ø±Ø¶ Ù„Ùƒ Ù…Ù†ØªØ¬Ø§Øª Ø±Ø§ÙŠÙ† Ù‡Ù†Ø§Ùƒ!" âœ… (Ù…Ù†Ø§Ø³Ø¨)
- Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙŠØ³Ø£Ù„ "Ø£ÙŠ Ø¹Ù„Ø§Ù…Ø§Øª Ø¹Ù†Ø¯ÙƒÙ…ØŸ" â†’ "Ø£ÙŠ Ù…Ø¯ÙŠÙ†Ø© Ø£Ù†Øª ÙÙŠÙ‡Ø§ØŸ Ø±Ø§Ø­ Ø£Ø¹Ø±Ø¶ Ù„Ùƒ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© Ù‡Ù†Ø§Ùƒ!" âœ… (Ù…Ù†Ø§Ø³Ø¨)
- Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙŠØ³Ø£Ù„ "ÙƒÙ… Ø³Ø¹Ø± Ø§Ù„Ù…ÙŠØ§Ù‡ØŸ" â†’ "Ø£ÙŠ Ø¹Ù„Ø§Ù…Ø© ÙˆÙ…Ø¯ÙŠÙ†Ø© ØªØ±ÙŠØ¯ØŸ Ø±Ø§Ø­ Ø£Ø¹Ø±Ø¶ Ù„Ùƒ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±!" âœ… (Ù…Ù†Ø§Ø³Ø¨)  
- Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙŠÙ‚ÙˆÙ„ "Ø£Ø¨ÙŠ ØªÙˆØµÙŠÙ„ Ù…ÙŠØ§Ù‡" â†’ "Ø£ÙŠ Ù…Ø¯ÙŠÙ†Ø© ÙˆØ£ÙŠ Ø¹Ù„Ø§Ù…Ø© ØªØ±ÙŠØ¯ØŸ" âœ… (Ù…Ù†Ø§Ø³Ø¨)
- Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙŠØ³Ø£Ù„ Ø¹Ù† Ø¹Ù„Ø§Ù…Ø© Ù…Ø¹ÙŠÙ†Ø© Ø¨Ø´ÙƒÙ„ Ø¹Ø§Ù… â†’ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¹Ù† Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ù„Ø¹Ø±Ø¶ Ù…Ù†ØªØ¬Ø§Øª Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© âœ… (Ù…Ù†Ø§Ø³Ø¨)
- Ø¥Ø®Ø¨Ø§Ø± Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¨Ø§Ù„Ø­Ù‚ÙŠÙ‚Ø© Ø¹Ù† Ø§Ù„ØªÙˆÙØ± Ø£ÙØ¶Ù„ Ù…Ù† Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø®Ø§Ø·Ø¦Ø© âœ…

ğŸš¨ Ù‚Ø§Ø¹Ø¯Ø© Ù…Ù‡Ù…Ø©: Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¹Ù† Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø£Ùˆ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ù…Ù†Ø§Ø³Ø¨ Ø¹Ù†Ø¯Ù…Ø§ ØªÙƒÙˆÙ† Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…Ø·Ù„ÙˆØ¨Ø© Ù„ØªÙ‚Ø¯ÙŠÙ… Ø®Ø¯Ù…Ø© Ø¯Ù‚ÙŠÙ‚Ø© âœ…

Ù‚ÙŠÙ‘Ù… Ø§Ù„Ø±Ø¯ ÙˆØ£Ø®Ø±Ø¬:
- is_appropriate: true Ø£Ùˆ false
- reason: Ø³Ø¨Ø¨ ÙˆØ§Ø¶Ø­ ÙˆÙ…Ø­Ø¯Ø¯ Ù„Ù„Ù‚Ø±Ø§Ø±
- confidence: Ø¯Ø±Ø¬Ø© Ø«Ù‚Ø© Ù…Ù† 0.0 Ø¥Ù„Ù‰ 1.0

Ø£Ø®Ø±Ø¬ Ø§Ù„Ù†Ø§ØªØ¬ Ø¨ØµÙŠØºØ© JSON ÙÙ‚Ø·:
{{"is_appropriate": true/false, "reason": "Ø§Ù„Ø³Ø¨Ø¨ Ø§Ù„Ù…ÙØµÙ„", "confidence": 0.0-1.0}}"""

            else:
                validation_prompt = f"""You are a strict quality evaluator for Abar Water Delivery Company customer service responses.

Your task: Determine if the generated response is appropriate and relevant to the customer's message.

Customer Message: "{user_message}"
Generated Response: "{generated_response}"

Previous Conversation Context (Last 3 messages):
{conversation_context}

ğŸ“‹ Query Agent Scope - Critical for Understanding Appropriate Responses:

ğŸ¯ What the Query Agent CAN do:
1. âœ… Show available cities for delivery
2. âœ… Show available water brands in each city
3. âœ… Show water products and prices for each brand
4. âœ… Search for brands in specific cities
5. âœ… Show cheapest products in a specific city
6. âœ… Answer questions about products, prices, and availability
7. âœ… Ask friendly questions to gather information (city, brand, product)
8. âœ… Direct customers to app/website for ordering
9. âœ… Handle general inquiries about water and water types

âŒ What the Query Agent CANNOT do:
1. âŒ Take actual orders or process payments
2. âŒ Schedule deliveries or handle actual delivery
3. âŒ Handle delivery driver or delivery problems
4. âŒ Modify or cancel existing orders
5. âŒ Handle complaints or service issues
6. âŒ Provide contact information or addresses
7. âŒ Handle requests to change locations or addresses

ğŸ”§ Available System Functions for Query Agent:
- get_all_cities(): Show all cities
- get_brands_by_city_name(): Show brands in city
- get_products_by_brand_and_city_name(): Show brand products in city
- search_brands_in_city(): Search for brands
- get_cheapest_products_by_city_name(): Cheapest products in city

ğŸ”„ Understanding Water Delivery Conversation Flow - Very Important:
Review the last 3 messages to understand context:

1ï¸âƒ£ When customer needs water delivery or asks about prices/brands:
   - If we don't know the city â†’ Asking "Which city are you in?" is appropriate âœ…
   - If we know the city â†’ Showing available brands in that city is appropriate âœ…
   
2ï¸âƒ£ If we know the city and customer wants specific brand or asks prices:
   - Showing available products for the specified brand is appropriate âœ…
   - Or asking "Which brand do you need?" if customer hasn't specified
   
3ï¸âƒ£ Helpful Customer Service:
   - Showing available options is better than just asking questions
   - Example: If we know city â†’ show available brands
   - Example: If we know brand â†’ show products and prices

Strict Evaluation Rules:

ğŸ”´ Response is INAPPROPRIATE if:
- Answers a completely different question than what customer asked
- Confuses contact requests with branches questions
- Confuses general delivery questions with door delivery questions  
- Provides information unrelated to customer's question
- Contains duplicate links in the same message
- Too generic and doesn't address the specific question
- Asks about brand without knowing the city first

âš ï¸ Warning: Don't reject responses that honestly answer about product availability!
ğŸŸ¢ Response is APPROPRIATE if:
- Accurately answers the customer's specific question
- Uses correct information based on question type
- Aligns with conversation context
- Provides relevant water service information when needed
- Follows logical flow: city â†’ available brands or products
- Shows available options instead of just asking about them
- Provides helpful information based on what we know from context
- Honestly answers about availability or non-availability of specific products (acceptable even without alternatives)

Common Error Examples:
- Customer asks about contact number â†’ Response talks about branches âŒ
- Customer asks about general delivery â†’ Response only about door delivery âŒ
- Customer asks about specific brand â†’ Generic response about all brands âŒ

Examples of Correct and Acceptable Responses:
- Customer asks about "Al Manhal water" â†’ "Sorry, Al Manhal water is currently not available" âœ… (Acceptable)
- Customer asks about specific brand â†’ "This brand is not available in Riyadh" âœ… (Acceptable)
- Telling customer the truth about availability is better than wrong information âœ…

Evaluate the response and output:
- is_appropriate: true or false
- reason: Clear, specific reason for decision
- confidence: Confidence score from 0.0 to 1.0

Output in JSON format only:
{{"is_appropriate": true/false, "reason": "detailed reason", "confidence": 0.0-1.0}}"""

            # Call language handler for evaluation
            evaluation_result = await language_handler.process_with_openai(
                validation_prompt,
                "Ø£Ù†Øª Ø®Ø¨ÙŠØ± ØªÙ‚ÙŠÙŠÙ… Ø¬ÙˆØ¯Ø© Ø®Ø¯Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡. Ù‚Ù… Ø¨Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø¨Ø¯Ù‚Ø© ÙˆØµØ±Ø§Ù…Ø©." if user_language == 'ar' else "You are a customer service quality evaluation expert. Evaluate strictly and accurately."
            )
            
            if not evaluation_result:
                print("âŒ Response validation failed - no result from language handler")
                return {"is_appropriate": True, "reason": "Validation failed - defaulting to appropriate", "confidence": 0.5}
            
            # Try to parse JSON result
            try:
                import json
                result = json.loads(evaluation_result.strip())
                
                # Ensure required keys exist
                if not all(key in result for key in ['is_appropriate', 'reason', 'confidence']):
                    raise ValueError("Missing required keys in validation result")
                
                print(f"ğŸ” Response validation result: {result['is_appropriate']} (confidence: {result['confidence']}) - {result['reason']}")
                print(f"ğŸ“ Generated response being validated: '{generated_response}'")
                return result
                
            except (json.JSONDecodeError, ValueError) as e:
                print(f"âŒ Failed to parse validation result: {str(e)}. Raw result: {evaluation_result}")
                # Default to appropriate if parsing fails
                return {"is_appropriate": True, "reason": "JSON parsing failed - defaulting to appropriate", "confidence": 0.5}
                
        except Exception as e:
            print(f"âŒ Error in response validation: {str(e)}")
            # Default to appropriate on error to avoid blocking responses
            return {"is_appropriate": True, "reason": f"Validation error: {str(e)}", "confidence": 0.5}

    async def process_query(self, user_message: str, conversation_history: List[Dict] = None, user_language: str = 'ar', journey_id: str = None) -> str:
        """
        Process user query using OpenAI with function calling capabilities with response validation and retry logic
        Enhanced with 2-attempt response validation to ensure appropriate responses
        """
        print(f"Processing query: {user_message} (Language: {user_language})")
        
        # Maximum number of attempts
        max_attempts = 1
        
        for attempt in range(1, max_attempts + 1):
            print(f"ğŸ”„ Response generation attempt {attempt}/{max_attempts}")
            
            try:
                # Generate response using internal method
                response = await self._generate_response_internal(user_message, conversation_history, user_language, journey_id)
                
                # If empty response, skip validation and try again
                if not response or response.strip() == "":
                    print(f"âš ï¸ Attempt {attempt} generated empty response")
                    if attempt < max_attempts:
                        continue
                    else:
                        # Return empty string when all attempts fail instead of error message
                        # This ensures no response is sent to customer and human agent can handle
                        return ""
                
                # Validate response appropriateness
                print(f"ğŸ” Validating response appropriateness for attempt {attempt}")
                validation_result = await self._validate_response_appropriateness(
                    user_message=user_message,
                    generated_response=response,
                    conversation_history=conversation_history,
                    user_language=user_language
                )
                
                if validation_result['is_appropriate']:
                    print(f"âœ… Response validated as appropriate (attempt {attempt})")
                    return response
                else:
                    print(f"âŒ Response deemed inappropriate (attempt {attempt}): {validation_result['reason']}")
                    if attempt < max_attempts:
                        print(f"ğŸ”„ Retrying response generation...")
                        continue
                    else:
                        print(f"âš ï¸ Max attempts reached and validation failed, not sending response")
                        return ""
                        
            except Exception as e:
                print(f"âŒ Error in attempt {attempt}: {str(e)}")
                if attempt < max_attempts:
                    continue
                else:
                    error_msg = "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰." if user_language == 'ar' else "Sorry, there was an error processing the query. Please try again."
                    return error_msg

    async def _generate_response_internal(self, user_message: str, conversation_history: List[Dict] = None, user_language: str = 'ar', journey_id: str = None) -> str:
        """
        Internal method for generating response (separated for retry logic)
        """
        # STEP 1: Check if message is relevant to water delivery services
        print("ğŸ” Checking message relevance...")
        is_relevant = await self._classify_message_relevance(user_message, conversation_history, user_language)
        
        if not is_relevant:
            print(f"âŒ Message not relevant to water delivery services: {user_message}...")
            # Return None or empty string to indicate the agent should not reply
            return ""
        
        print("âœ… Message is relevant to water delivery services")

        # STEP 2: Check for total price questions - redirect to app/website
        if self._check_for_total_price_question(user_message):
            if user_language == 'ar':
                return "Ø¨ØªØ­ØµÙ„ Ø§Ù„Ø§ØµÙ†Ø§Ù ÙˆØ§Ù„Ø§Ø³Ø¹Ø§Ø± ÙÙŠ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ÙˆÙ‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„Ø±Ø§Ø¨Ø· https://onelink.to/abar_app https://abar.app/en/store/ ÙˆØ§ÙŠØ¶Ø§ Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø§Ù„ÙƒØªØ±ÙˆÙ†ÙŠ"
            else:
                return "You can find all products and prices in our app: https://onelink.to/abar_app or on our website: https://abar.app/en/store/"

        # STEP 3: Check if this is a "yes" response to a previous product question
        if self._check_for_yes_response(user_message, conversation_history):
            print("âœ… Detected 'yes' response - handling product confirmation")
        
        max_function_calls = 5
        function_call_count = 0
        
        try:
            # Check if we already have city information from current message or conversation history
            city_context = await self._extract_city_from_context(user_message, conversation_history)
            
            # Check if we have brand information
            brand_context = await self._extract_brand_from_context(
                user_message, 
                conversation_history, 
                city_context.get("city_name") if city_context else None  # â† Uses CITY name for brand search
            )
            
            # Prepare conversation history
            messages = []
            
            # System message with instructions based on user language
            city_info = ""
            brand_info = ""
            
            if city_context:
                if 'district' in city_context.get('found_in', ''):
                    found_where = "current message district" if 'current_message_district' in city_context['found_in'] else "conversation history district"
                    district_name = city_context.get('district_name', 'unknown district')
                    city_info = f"\n\nIMPORTANT CONTEXT: The customer mentioned {district_name} district which maps to {city_context['city_name_en']} ({city_context['city_name']}) - detected from {found_where}. Use the CITY name ({city_context['city_name']}) for all brand/product searches, but you can acknowledge their district for context. ğŸš¨ MANDATORY: Since you know the city, immediately call get_brands_by_city_name('{city_context['city_name']}') to show available brands."
                else:
                    found_where = "current message" if city_context['found_in'] == "current_message" else "conversation history"
                    city_info = f"\n\nIMPORTANT CONTEXT: The customer is from {city_context['city_name_en']} ({city_context['city_name']}) - detected from {found_where}. You already know their city, so you can show products and brands for this city without asking again. ğŸš¨ MANDATORY: Since you know the city, immediately call get_brands_by_city_name('{city_context['city_name']}') to show available brands."
            
            if brand_context:
                found_where = "current message" if brand_context['found_in'] == "current_message" else "conversation history"
                if city_context:
                    brand_info = f"\n\nBRAND CONTEXT: The customer mentioned '{brand_context['brand_title']}' - detected from {found_where}. ğŸš¨ MANDATORY: Since you know both city ({city_context['city_name']}) and brand ({brand_context['brand_title']}), immediately call get_products_by_brand_and_city_name('{brand_context['brand_title']}', '{city_context['city_name']}') to show products."
                else:
                    brand_info = f"\n\nBRAND CONTEXT: The customer mentioned '{brand_context['brand_title']}' - detected from {found_where}. You know the brand but need to ask for the city first, then show products."
            
            if user_language == 'en':
                system_message = {
                    "role": "system",
                    "content": f"""You are a friendly customer service employee at Abar Water Delivery Company in Saudi Arabia.{city_info}{brand_info}

                    ğŸ“‹ Important terminology for understanding Arabic customers (for understanding only - don't mention to customers):
                    - "Ù‚ÙˆØ§Ø±ÙŠØ± Ø§Ù„Ù…ÙŠØ§Ù‡" = "Ø§Ù„Ø¬ÙˆØ§Ù„ÙŠÙ†" (same product - water gallons)
                    - "Ø­Ø¨Ø© Ù…ÙŠØ§Ù‡" = "Ø²Ø¬Ø§Ø¬Ø© Ù…ÙŠØ§Ù‡" (common term - means water bottle)
                    - "Ù…Ù‚Ø§Ø³" = size/volume (e.g., "Ù…Ù‚Ø§Ø³ 200 Ù…Ù„" means 200ml size)
                    - Example: "Ø§Ø­ØªØ§Ø¬ ÙƒØ±ØªÙˆÙ†Ø© 48 Ø­Ø¨Ø© Ù…Ù‚Ø§Ø³ 200 Ù…Ù„" = "I need a carton of 48 bottles, 200ml size"

                    Your job is to help customers with:
                    1. Finding available cities for water delivery service
                    2. Showing water brands available in each city
                    3. Displaying water products and their prices from each brand
                    4. Answering questions naturally and helpfully
                    5. Asking friendly questions when you need more information

                    ğŸ™ï¸ Smart City Name Extraction - Very Important:
                    - When you suspect a word in the current message or conversation history might be a city name
                    - ALWAYS use the get_all_cities() function to get the complete list of cities we serve
                    - Compare the suspected word with the available cities list
                    - Get the correct and complete city name from the list
                    - Use the correct name with other functions like get_brands_by_city_name and get_products_by_brand_and_city_name
                    - ğŸš¨ CRITICAL: Never tell a customer we don't serve their city without first calling get_all_cities() to verify
                    
                    

                    Communication Style:
                    - Talk like a real human customer service representative
                    - Be natural, warm, and conversational
                    - Never use phrases like "AI response", "Assistant reply", or "I am an AI"
                    - Respond as if you're a real person working for the company

                    ENHANCED WORKFLOW - SMART CONTEXT EXTRACTION:
                    ğŸš¨ ALWAYS follow this sequence but use extracted context: CITY â†’ BRAND â†’ PRODUCTS â†’ RESPONSE

                    SMART BRAND HANDLING:
                    - If customer mentions ONLY a brand name (e.g., "Nestle", "Aquafina"), extract city from context
                    - If you know BOTH city and brand: directly show products for that brand in that city
                    - If you know brand but NOT city: ask for city, then show products
                    - If customer says "yes" after you asked about a product: provide the price/details

                    ğŸš¨ ENHANCED CONVERSATION HISTORY ATTENTION - CRITICAL:
                    - Always thoroughly review conversation history to find previously mentioned cities and brands
                    - Search through the last 5 messages for any mention of city names or brand names
                    - Do not ask for information that already exists in conversation history
                    - Use extracted information from history even if it's from older messages

                    ğŸš¨ MANDATORY FUNCTION CALLING - CRITICAL:
                    - When you know the city but need to show brands: IMMEDIATELY call get_brands_by_city_name function
                    - When you know both city and brand but need products: IMMEDIATELY call get_products_by_brand_and_city_name function
                    - NEVER say "let me check" or "one moment" without actually calling the function
                    - If system provides city context, use the function calls immediately in the same response
                    - Do NOT provide generic responses - always use functions to get real data

                    ğŸš¨ DISTRICT-TO-CITY MAPPING SYSTEM - CRITICAL:
                    - The system automatically detects DISTRICT NAMES (neighborhoods) in user messages
                    - Districts are automatically mapped to their corresponding CITIES for all business operations
                    - When customer mentions districts like "Ø­ÙŠ Ø§Ù„Ø­Ù…Ø±Ø§Ø¡ Ø§Ù„Ø£ÙˆÙ„", "Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…Ø¹Ù„Ù…ÙŠÙ†", "Ø§Ù„Ø­ÙŠ Ø§Ù„Ø´Ù…Ø§Ù„ÙŠ" etc.:
                    â†’ System maps them to corresponding cities (e.g., "Ø§Ù„Ø­Ù…Ø±Ø§Ø¡ Ø§Ù„Ø£ÙˆÙ„" â†’ "Ø§Ù„Ø£Ø­Ø³Ø§Ø¡")
                    â†’ ALL business operations (brands/products search) use the CITY name, NOT district name
                    â†’ District names are kept for context and customer communication only
                    - ğŸš¨ CRITICAL: If system context shows district mapping, NEVER ask for city - you already have it!
                    - When you see context like "Customer mentioned [district] district which maps to [city]":
                    â†’ IMMEDIATELY proceed with the mapped city for all operations
                    â†’ DO NOT ask "Which city are you in?" - you already know the city from district mapping
                    â†’ Acknowledge the district but use the city: "I'll show you brands/products available in [city] for [district] district"
                    - You can acknowledge the district for customer context: "I found your request for Ø§Ù„Ø­Ù…Ø±Ø§Ø¡ Ø§Ù„Ø£ÙˆÙ„ district"
                    - NEVER search for brands/products using district names directly
                    - MIXED QUERIES: If customer mentions BOTH city and district (e.g., "Ø¬Ø¯Ø© Ø­ÙŠ Ø§Ù„Ø­Ù…Ø±Ø§Ø¡ Ø§Ù„Ø£ÙˆÙ„"), direct city name takes priority over district mapping

                    CITY DETECTION PRIORITY - WITH STRONG FOCUS ON HISTORY:
                    1. Check if city is mentioned in current user message (direct city names have priority)
                    2. Check if district is mentioned (system will map to city automatically - NEVER ask for city if district found!)
                    3. ğŸš¨ Search thoroughly through conversation history (last 5 messages) for any city mentions
                    4. Search thoroughly through conversation history for any district mentions
                    5. Only if NO city/district found in current message OR history - ask for city

                    ğŸš¨ CRITICAL RULE: If system provides district-to-city mapping in context, you already have the city!
                    - NEVER ask "Which city are you in?" when district mapping context is provided
                    - District mapping = automatic city knowledge = proceed immediately with business logic
                    - Use this phrase to ask about city: "Which city are you in? I need to know your location." - ONLY when NO district/city found anywhere

                    BRAND DETECTION PRIORITY - WITH STRONG FOCUS ON HISTORY:
                    1. Check if brand is mentioned in current user message
                    2. ğŸš¨ Search thoroughly through conversation history (last 5 messages) for any brand mentions
                    3. If brand is mentioned but city unknown - ask for city
                    4. If both city and brand known - show products directly
                    5. Only if NO brand found in current message OR history - ask for brand

                    ğŸš¨ SPECIAL HANDLING FOR PRICE QUESTIONS - CRITICAL INSTRUCTIONS:
                    When customer asks about prices with "how much" or "what's the price":
                    - The word after "how much" or "what's the price of" is usually either a brand or size
                    - If you don't understand the word that comes after price questions, it's likely a brand name
                    - Use search_brands_in_city function to search for the brand in the known city
                    - Examples: "How much is Nestle?" - "What's the price of Aquafina?" - "How much Volvic?"
                    - Even if the brand name is misspelled or unfamiliar, try searching for it

                    ğŸš¨ HANDLING WATER WORDS BEFORE BRAND NAMES - CRITICAL:
                    - Customers may mention words like "Ù…ÙŠØ§Ù‡" (water), "Ù…ÙˆÙŠØ©" (water), "Ù…ÙŠØ§Ø©" (water), "water" before brand names
                    - Examples: "Ù…ÙŠØ§Ù‡ ÙˆÙŠ" (We water) - "Ù…ÙˆÙŠØ© Ù†Ù‚ÙŠ" (Naqi water) - "water Nestle" - "Ù…ÙŠØ§Ù‡ Ù†Ø³ØªÙ„Ù‡"
                    - These water words are NOT part of the actual brand name
                    - The system automatically removes these prefixes when searching
                    - So "Ù…ÙŠØ§Ù‡ ÙˆÙŠ" becomes just "ÙˆÙŠ" for database search
                    - Consider these words as descriptors, not part of the brand name

                    PROACTIVE HANDLING:
                    - "Nestle" + known city â†’ Show Nestle products in that city
                    - "Aquafina" + no known city â†’ "Which city are you in? I'll show you Aquafina products there!"
                    - "yes" after product question â†’ Provide price and details
                    - General price questions â†’ Direct to app/website links
                    - "How much [unknown word]?" â†’ Try searching it as a brand name first

                    ğŸš¨ PRICE INQUIRY HANDLING - CRITICAL INSTRUCTIONS:
                    When customers ask about prices of ANY product or service:
                    1. ALWAYS ensure you know the CITY first
                    - If city is unknown: Ask "Which city are you in? I need to know your location to show accurate prices."
                    - Use extracted city context if available
                    2. ALWAYS ensure you know the BRAND/COMPANY first
                    - If brand is unknown: Ask "Which brand are you interested in? I'll show you their prices in your city."
                    - Use extracted brand context if available
                    3. ONLY after you have BOTH city AND brand â†’ Use get_products_by_brand function to get specific prices for that brand
                    4. If customer asks for general prices without specifying brand/city â†’ Always ask for both before providing any price information

                    Never provide generic or estimated prices. Always get specific product prices for the exact brand in the specific city.

                    ORDER REQUESTS - REDIRECT TO APP:
                    When user wants to place an order, make a purchase, or asks how to order, ALWAYS redirect them to the app/website with this message:
                    "You can find all products, prices, and place orders through our app: https://onelink.to/abar_app or on our website: https://abar.app/en/store/"
                    - Never try to take orders through the chat
                    - Never ask for delivery details, payment info, or personal information
                    - Always direct them to the official app/website for ordering

                    ğŸš¨ APP PROMOTION - ONLY IN SPECIFIC CASES:
                    - When showing specific products/prices for a brand, add at the end: "You can order through our app: https://onelink.to/abar_app"
                    - Don't repeat links if they already exist in the response
                    - If city is not available, just use the predefined simple response

                    ğŸš¨ CITY NOT AVAILABLE - CRITICAL INSTRUCTIONS:
                    - BEFORE saying we don't deliver to any city, you MUST first call get_all_cities() function
                    - Compare the user's city name with ALL cities we serve to ensure it's not a spelling mistake
                    - Only AFTER confirming the city is truly not in our service list, then use this exact response: "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ø§ Ù†Ù‚Ø¯Ù… Ø®Ø¯Ù…Ø© Ø§Ù„ØªÙˆØµÙŠÙ„ Ù„Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø­Ø§Ù„ÙŠØ§Ù‹"
                    - This protects us from incorrectly rejecting customers due to spelling variations or typos
                    - DO NOT add explanations or additional text beyond this message
                    - Be direct and clear about unavailability only after verification

                    ğŸš¨ CRITICAL RULE - BE DIRECT ABOUT SERVICE AVAILABILITY:
                    - When a city is not serviced, clearly state: "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ø§ Ù†Ù‚Ø¯Ù… Ø®Ø¯Ù…Ø© Ø§Ù„ØªÙˆØµÙŠÙ„ Ù„Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø­Ø§Ù„ÙŠØ§Ù‹"
                    - When a brand is not available in a city, clearly state: "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© ØºÙŠØ± Ù…ØªÙˆÙØ±Ø© ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø­Ø§Ù„ÙŠØ§Ù‹"
                    - Be direct and honest with customers about availability
                    - This applies to cities and brand availability questions

                    ğŸš¨ SPECIFIC BUSINESS RULES - CRITICAL:

                    1. APARTMENT DOOR DELIVERY:
                    - ONLY when customer uses specific phrases like "apartment door", "flat door", "door delivery", "deliver to my door", or mentions specific floors ("1st floor", "2nd floor", "3rd floor"), answer: "We deliver to apartment doors if there is an elevator, and if there is no elevator we deliver to the 1st, 2nd, and 3rd floors maximum with a request to add a note with your order through the app."
                    - Do NOT use this response for general delivery questions

                    2. JUG EXCHANGE SERVICE:
                    - Jug exchange is ONLY available in specified cities, not outside them
                    - Jug exchange is NOT available for Al-Manhal brand yet
                    - Always mention these limitations when discussing jug exchange

                    3. BRANCHES QUESTION:
                    - ONLY when customer specifically mentions "branches", "physical stores", "offices", "locations", "do you have branches", answer: "We don't have physical branches, but we deliver to many cities."
                    - Do NOT use this response for contact information, phone number requests, or other questions

                    4. CONTACT INFORMATION REQUESTS:
                    - ONLY when customer specifically asks about "phone number", "contact number", "how to contact", "get in touch", "call you", "reach you", answer: "You can contact us through our app or website for technical support and customer service: https://onelink.to/abar_app or https://abar.app/en/store/"
                    - Do NOT confuse contact requests with branches questions

                    5. PRICE DISPUTES:
                    - If customer asks about product price and claims it's available at a lower price elsewhere, DO NOT agree or confirm lower prices
                    - ONLY provide prices from our official data - never generate or estimate prices
                    - Always use the get_products_by_brand function for accurate pricing information

                    Important rules:
                    - Always use available functions to get updated information
                    - For city queries: use search_cities to handle typos and fuzzy matching, and get_all_cities to verify availability
                    - Before declaring a city unserviced, ALWAYS verify with get_all_cities first
                    - Be patient with typos and spelling variations
                    - Respond in English since the customer is communicating in English
                    - Keep responses helpful and conversational like a real person would
                    - Use context smartly - don't ask for information you already have
                    - Don't repeat links in the same message - each link should appear only once

                    ğŸš¨ CRITICAL RULE - USE NAMES, NOT IDs:
                    - NEVER mention or use internal database ID numbers in your responses
                    - ALWAYS work with city names and brand names directly
                    - Use get_brands_by_city_name to get brands for a specific city by name
                    - Use get_products_by_brand_and_city_name to get products for a brand in a city by names
                    - Use search_brands_in_city to find brands with fuzzy matching
                    - The system handles incomplete and misspelled names automatically
                    - Always use descriptive names that customers understand

                    ğŸš¨ DISPLAY ALL PRODUCTS - CRITICAL:
                    - When showing products for a specific brand, you MUST display ALL products without exception
                    - Do not abbreviate or limit to only some products
                    - Show the complete list of all available products for the brand in the city
                    - Ensure you display product name, size, and price for each product

                    Be helpful, understanding, and respond exactly like a friendly human employee would."""
                                    }

                    
                # Check user message and conversation history for size-related keywords (English)
                all_conversation_text = user_message
                if conversation_history:
                    for msg in conversation_history[-5:]:  # Check last 5 messages
                        all_conversation_text += " " + msg.get("content", "")
                
                if "quarter" in all_conversation_text or "half" in all_conversation_text or "riyal" in all_conversation_text:
                    system_message["content"] += "\n\nAdditional info: Quarter size = 200ml or 250ml, Half size = 330ml or 300ml, Riyal size = 600ml or 550ml, Two Riyal size = 1.5L"
                if "groundwater" in all_conversation_text or "artesian" in all_conversation_text:
                    system_message["content"] += (
                        "\n\nAdditional info: Groundwater/artesian water brands include: "
                        "Nova, Naqi, Berrin, Mawared, B, Vio, Miles, Aquaya, Aqua 8, Mana, Tania, Abar Hail, Oska, Nestle, Ava, Hena, Saqya Al Madina, Deman, Hani, Sahtak, Halwa, Athb, Aus, Qataf, Rest, Eval, We."
                    )
                if "gallon" in all_conversation_text:
                    system_message["content"] += (
                        "\n\nGallon exchange services available in:\n"
                        "Tania â€“ Riyadh\n"
                        "Safia â€“ Riyadh\n"
                        "Yanabee Al Mahbooba â€“ Medina"
                    )
            else:
                city_info_ar = ""
                brand_info_ar = ""
                
                if city_context:
                    if 'district' in city_context.get('found_in', ''):
                        found_where_ar = "Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© (Ø­ÙŠ)" if 'current_message_district' in city_context['found_in'] else "ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© (Ø­ÙŠ)"
                        district_name = city_context.get('district_name', 'Ø­ÙŠ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
                        city_info_ar = f"\n\nØ³ÙŠØ§Ù‚ Ù…Ù‡Ù…: Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø°ÙƒØ± Ø­ÙŠ {district_name} ÙˆØ§Ù„Ø°ÙŠ ÙŠØ±Ø¨Ø· Ø¨Ù…Ø¯ÙŠÙ†Ø© {city_context['city_name']} ({city_context['city_name_en']}) - ØªÙ… Ø§ÙƒØªØ´Ø§ÙÙ‡ Ù…Ù† {found_where_ar}. Ø§Ø³ØªØ®Ø¯Ù… Ø§Ø³Ù… Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© ({city_context['city_name']}) Ù„Ø¬Ù…ÙŠØ¹ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©/Ø§Ù„Ù…Ù†ØªØ¬Ø§ØªØŒ ÙˆÙ„ÙƒÙ† ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø§Ø¹ØªØ±Ø§Ù Ø¨Ø­ÙŠÙ‡Ù… Ù„Ù„Ø³ÙŠØ§Ù‚. ğŸš¨ Ø¥Ø¬Ø¨Ø§Ø±ÙŠ: Ø¨Ù…Ø§ Ø£Ù†Ùƒ ØªØ¹Ø±Ù Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©ØŒ Ø§Ø³ØªØ¯Ø¹ÙŠ ÙÙˆØ±Ø§Ù‹ get_brands_by_city_name('{city_context['city_name']}') Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø§Ù„Ù…ØªØ§Ø­Ø©."
                    else:
                        found_where_ar = "Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©" if city_context['found_in'] == "current_message" else "ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©"
                        city_info_ar = f"\n\nØ³ÙŠØ§Ù‚ Ù…Ù‡Ù…: Ø§Ù„Ø¹Ù…ÙŠÙ„ Ù…Ù† {city_context['city_name']} ({city_context['city_name_en']}) - ØªÙ… Ø§ÙƒØªØ´Ø§ÙÙ‡Ø§ Ù…Ù† {found_where_ar}. Ø£Ù†Øª ØªØ¹Ø±Ù Ù…Ø¯ÙŠÙ†ØªÙ‡Ù… Ø¨Ø§Ù„ÙØ¹Ù„ØŒ Ù„Ø°Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙˆØ§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ù„Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø¨Ø¯ÙˆÙ† Ø§Ù„Ø³Ø¤Ø§Ù„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰. ğŸš¨ Ø¥Ø¬Ø¨Ø§Ø±ÙŠ: Ø¨Ù…Ø§ Ø£Ù†Ùƒ ØªØ¹Ø±Ù Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©ØŒ Ø§Ø³ØªØ¯Ø¹ÙŠ ÙÙˆØ±Ø§Ù‹ get_brands_by_city_name('{city_context['city_name']}') Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø§Ù„Ù…ØªØ§Ø­Ø©."
                
                if brand_context:
                    found_where_ar = "Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©" if brand_context['found_in'] == "current_message" else "ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©"
                    if city_context:
                        brand_info_ar = f"\n\nØ³ÙŠØ§Ù‚ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©: Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø°ÙƒØ± '{brand_context['brand_title']}' - ØªÙ… Ø§ÙƒØªØ´Ø§ÙÙ‡Ø§ Ù…Ù† {found_where_ar}. ğŸš¨ Ø¥Ø¬Ø¨Ø§Ø±ÙŠ: Ø¨Ù…Ø§ Ø£Ù†Ùƒ ØªØ¹Ø±Ù Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© ({city_context['city_name']}) ÙˆØ§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© ({brand_context['brand_title']})ØŒ Ø§Ø³ØªØ¯Ø¹ÙŠ ÙÙˆØ±Ø§Ù‹ get_products_by_brand_and_city_name('{brand_context['brand_title']}', '{city_context['city_name']}') Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª."
                    else:
                        brand_info_ar = f"\n\nØ³ÙŠØ§Ù‚ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©: Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø°ÙƒØ± '{brand_context['brand_title']}' - ØªÙ… Ø§ÙƒØªØ´Ø§ÙÙ‡Ø§ Ù…Ù† {found_where_ar}. Ø£Ù†Øª ØªØ¹Ø±Ù Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ù„ÙƒÙ† ØªØ­ØªØ§Ø¬ Ù„Ø³Ø¤Ø§Ù„ Ø¹Ù† Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø£ÙˆÙ„Ø§Ù‹ØŒ Ø«Ù… Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª."
                
                system_message = {
                    "role": "system",
                    "content": f"""Ø£Ù†Øª Ù…ÙˆØ¸Ù Ø®Ø¯Ù…Ø© Ø¹Ù…Ù„Ø§Ø¡ ÙˆØ¯ÙˆØ¯ ÙÙŠ Ø´Ø±ÙƒØ© Ø£Ø¨Ø§Ø± Ù„ØªÙˆØµÙŠÙ„ Ø§Ù„Ù…ÙŠØ§Ù‡ ÙÙŠ Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©.{city_info_ar}{brand_info_ar}

                    ğŸ“‹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…Ù‡Ù…Ø© Ù„ÙÙ‡Ù… Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª (Ù„Ù„ÙÙ‡Ù… ÙÙ‚Ø· - Ù„Ø§ ØªØ°ÙƒØ±Ù‡Ø§ Ù„Ù„Ø¹Ù…ÙŠÙ„):
                    - Ù‚ÙˆØ§Ø±ÙŠØ± Ø§Ù„Ù…ÙŠØ§Ù‡ = Ø§Ù„Ø¬ÙˆØ§Ù„ÙŠÙ† (Ù†ÙØ³ Ø§Ù„Ù…Ù†ØªØ¬)
                    - "Ø­Ø¨Ø© Ù…ÙŠØ§Ù‡" = "Ø²Ø¬Ø§Ø¬Ø© Ù…ÙŠØ§Ù‡" (Ù…ØµØ·Ù„Ø­ Ø´Ø§Ø¦Ø¹)
                    - "Ù…Ù‚Ø§Ø³" = Ø§Ù„Ø­Ø¬Ù…/Ø§Ù„Ø³Ø¹Ø© (Ù…Ø«Ù„: "Ù…Ù‚Ø§Ø³ 200 Ù…Ù„" ØªØ¹Ù†ÙŠ Ø­Ø¬Ù… 200 Ù…Ù„)
                    - Ù…Ø«Ø§Ù„: "Ø§Ø­ØªØ§Ø¬ ÙƒØ±ØªÙˆÙ†Ø© 48 Ø­Ø¨Ø© Ù…Ù‚Ø§Ø³ 200 Ù…Ù„" = "Ø§Ø­ØªØ§Ø¬ ÙƒØ±ØªÙˆÙ†Ø© 48 Ø²Ø¬Ø§Ø¬Ø© Ø­Ø¬Ù… 200 Ù…Ù„"

                    ÙˆØ¸ÙŠÙØªÙƒ Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ ÙÙŠ:
                    1. Ø¥ÙŠØ¬Ø§Ø¯ Ø§Ù„Ù…Ø¯Ù† Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ø®Ø¯Ù…Ø© ØªÙˆØµÙŠÙ„ Ø§Ù„Ù…ÙŠØ§Ù‡
                    2. Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ù„Ù„Ù…ÙŠØ§Ù‡ Ø§Ù„Ù…ØªØ§Ø­Ø© ÙÙŠ ÙƒÙ„ Ù…Ø¯ÙŠÙ†Ø©  
                    3. Ø¹Ø±Ø¶ Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ù…ÙŠØ§Ù‡ ÙˆØ£Ø³Ø¹Ø§Ø±Ù‡Ø§ Ù…Ù† ÙƒÙ„ Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ©
                    4. Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø¨Ø·Ø±ÙŠÙ‚Ø© Ø·Ø¨ÙŠØ¹ÙŠØ© ÙˆÙ…ÙÙŠØ¯Ø©
                    5. Ø·Ø±Ø­ Ø£Ø³Ø¦Ù„Ø© ÙˆØ¯ÙˆØ¯Ø© Ø¹Ù†Ø¯Ù…Ø§ ØªØ­ØªØ§Ø¬ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø£ÙƒØ«Ø±

                    ğŸ™ï¸ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø¯Ù† Ø§Ù„Ø°ÙƒÙŠ - Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹:
                    - Ø¹Ù†Ø¯Ù…Ø§ ØªØ´Ùƒ Ø£Ù† ÙƒÙ„Ù…Ø© ÙÙŠ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø£Ùˆ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ù‚Ø¯ ØªÙƒÙˆÙ† Ø§Ø³Ù… Ù…Ø¯ÙŠÙ†Ø©
                    - Ø§Ø³ØªØ®Ø¯Ù… Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ø§Ù„ÙˆØ¸ÙŠÙØ© get_all_cities() Ù„ØªØ­ØµÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ù„Ù„Ù…Ø¯Ù† Ø§Ù„ØªÙŠ Ù†Ø®Ø¯Ù…Ù‡Ø§
                    - Ù‚Ø§Ø±Ù† Ø§Ù„ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡Ø© Ù…Ø¹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø¯Ù† Ø§Ù„Ù…ØªØ§Ø­Ø©
                    - Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø§Ø³Ù… Ø§Ù„ØµØ­ÙŠØ­ ÙˆØ§Ù„ÙƒØ§Ù…Ù„ Ù„Ù„Ù…Ø¯ÙŠÙ†Ø© Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
                    - Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø§Ø³Ù… Ø§Ù„ØµØ­ÙŠØ­ Ù…Ø¹ Ø§Ù„ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø£Ø®Ø±Ù‰ Ù…Ø«Ù„ get_brands_by_city_name and  get_products_by_brand_and_city_name
                    - ğŸš¨ Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹: Ù„Ø§ ØªØ®Ø¨Ø± Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø£Ø¨Ø¯Ø§Ù‹ Ø£Ù†Ù†Ø§ Ù„Ø§ Ù†Ø®Ø¯Ù… Ù…Ø¯ÙŠÙ†ØªÙ‡ Ø¨Ø¯ÙˆÙ† Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ get_all_cities() Ù„Ù„ØªØ­Ù‚Ù‚ Ø£ÙˆÙ„Ø§Ù‹
                    
                    ğŸš¨ ØªØ·Ø¨ÙŠØ¹ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø¯Ù† Ø§Ù„Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹:
                    - Ù…Ø¯ÙŠÙ†Ø© Ø¬ÙŠØ²Ø§Ù† Ù‡ÙŠ Ù†ÙØ³Ù‡Ø§ Ù…Ø¯ÙŠÙ†Ø© Ø¬Ø§Ø²Ø§Ù† (Ù†ÙØ³ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ù„ÙƒÙ† ÙƒØªØ§Ø¨Ø© Ù…Ø®ØªÙ„ÙØ©)
                    - Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ù‚Ø¯ ÙŠÙƒØªØ¨ÙˆÙ† "Ø¬ÙŠØ²Ø§Ù†" Ù„ÙƒÙ† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØªØ­ÙØ¸Ù‡Ø§ ÙƒÙ€ "Ø¬Ø§Ø²Ø§Ù†"
                    - Ø§Ø³ØªØ®Ø¯Ù… Ø¯Ø§Ø¦Ù…Ø§Ù‹ "Ø¬Ø§Ø²Ø§Ù†" Ø¹Ù†Ø¯ Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù‡Ù…Ø§ ÙƒØ§Ù† Ø·Ø±ÙŠÙ‚Ø© ÙƒØªØ§Ø¨Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
                    - Ø¥Ø°Ø§ Ø°ÙƒØ± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… "Ø¬ÙŠØ²Ø§Ù†"ØŒ Ø·Ø¨Ø¹Ù‡Ø§ Ù„Ù€ "Ø¬Ø§Ø²Ø§Ù†" Ù„Ø¬Ù…ÙŠØ¹ Ø¹Ù…Ù„ÙŠØ§Øª Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
                    
                    ğŸ“ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø¯Ù† Ø§Ù„Ù…Ø®ØªØµØ±Ø© - Ø§Ù†ØªØ¨Ù‡ Ù„Ù‡Ø°Ø§ Ø¨Ø´ÙƒÙ„ Ù‚ÙˆÙŠ Ø¬Ø¯Ø§Ù‹:
                    - Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø£Ø­ÙŠØ§Ù†Ø§Ù‹ ÙŠÙ‚ÙˆÙ„ÙˆÙ† "Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©" Ø£Ùˆ "Ø§Ù„Ù…Ø¯ÙŠÙ†Ù‡" Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† "Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ù…Ù†ÙˆØ±Ø©"
                    - Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø£Ø­ÙŠØ§Ù†Ø§Ù‹ ÙŠÙ‚ÙˆÙ„ÙˆÙ† "Ù…ÙƒØ©" Ø£Ùˆ "Ù…ÙƒÙ‡" Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† "Ù…ÙƒØ© Ø§Ù„Ù…ÙƒØ±Ù…Ø©"
                    - Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø£Ø­ÙŠØ§Ù†Ø§Ù‹ ÙŠÙ‚ÙˆÙ„ÙˆÙ† "Ø§Ù„Ø®Ù…ÙŠØ³" Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† "Ø®Ù…ÙŠØ³ Ù…Ø´ÙŠØ·"
                    - ğŸš¨ Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹: Ø¹Ù†Ø¯Ù…Ø§ ØªØ³Ù…Ø¹ "Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©" ÙÙŠ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø£Ùˆ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©ØŒ ØªØ¹Ø§Ù…Ù„ Ù…Ø¹Ù‡Ø§ ÙÙˆØ±Ø§Ù‹ ÙƒØ£Ù†Ù‡Ø§ "Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ù…Ù†ÙˆØ±Ø©"
                    - ğŸš¨ Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹: Ø¹Ù†Ø¯Ù…Ø§ ØªØ³Ù…Ø¹ "Ø§Ù„Ø®Ù…ÙŠØ³" ÙÙŠ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø£Ùˆ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©ØŒ ØªØ¹Ø§Ù…Ù„ Ù…Ø¹Ù‡Ø§ ÙÙˆØ±Ø§Ù‹ ÙƒØ£Ù†Ù‡Ø§ "Ø®Ù…ÙŠØ³ Ù…Ø´ÙŠØ·"
                    - ğŸš¨ Ø®Ø§ØµØ© Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙ‚ÙˆÙ„ Ø§Ù„Ø¹Ù…ÙŠÙ„ "Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©" Ø£Ùˆ "ÙÙŠ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©" - Ù‡Ø°Ø§ ÙŠØ¹Ù†ÙŠ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ù…Ù†ÙˆØ±Ø© Ø¨Ù„Ø§ Ø´Ùƒ
                    - ğŸš¨ Ø®Ø§ØµØ© Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙ‚ÙˆÙ„ Ø§Ù„Ø¹Ù…ÙŠÙ„ "ØªÙˆØµÙŠÙ„ Ø§Ù„Ø®Ù…ÙŠØ³" Ø£Ùˆ "ÙÙŠ Ø§Ù„Ø®Ù…ÙŠØ³" Ø£Ùˆ "Ù…ØªÙˆÙØ± ÙÙŠ Ø§Ù„Ø®Ù…ÙŠØ³" - Ù‡Ø°Ø§ ÙŠØ¹Ù†ÙŠ Ø®Ù…ÙŠØ³ Ù…Ø´ÙŠØ· Ø¨Ù„Ø§ Ø´Ùƒ
                    - Ø¬Ù…ÙŠØ¹ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¯Ù† ÙŠØªÙ… Ø§Ù„ØªÙˆØµÙŠÙ„ Ù„Ù‡Ø§
                    - Ù„Ø§ ØªØ³Ø£Ù„ Ø¹Ù† Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø¥Ø°Ø§ Ø°ÙƒØ± Ø§Ù„Ø¹Ù…ÙŠÙ„ "Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©" Ø£Ùˆ "Ø§Ù„Ø®Ù…ÙŠØ³" ÙÙŠ Ø£ÙŠ ØµÙŠØºØ©
                   

                    Ø£Ø³Ù„ÙˆØ¨ Ø§Ù„ØªÙˆØ§ØµÙ„:
                    - ØªÙƒÙ„Ù… Ù…Ø«Ù„ Ù…ÙˆØ¸Ù Ø®Ø¯Ù…Ø© Ø¹Ù…Ù„Ø§Ø¡ Ø­Ù‚ÙŠÙ‚ÙŠ
                    - ÙƒÙ† Ø·Ø¨ÙŠØ¹ÙŠ ÙˆÙˆØ¯ÙˆØ¯ ÙˆÙ…Ø­Ø§Ø¯Ø«ÙŠ
                    - Ù„Ø§ ØªØ³ØªØ®Ø¯Ù… Ø£Ø¨Ø¯Ø§Ù‹ Ø¹Ø¨Ø§Ø±Ø§Øª Ù…Ø«Ù„ "Ø±Ø¯ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ" Ø£Ùˆ "Ø±Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯" Ø£Ùˆ "Ø£Ù†Ø§ Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ"
                    - Ø±Ø¯ ÙƒØ£Ù†Ùƒ Ø´Ø®Øµ Ø­Ù‚ÙŠÙ‚ÙŠ ÙŠØ¹Ù…Ù„ ÙÙŠ Ø§Ù„Ø´Ø±ÙƒØ©

                    ğŸš¨ Ø§Ù„Ø§Ù†ØªØ¨Ø§Ù‡ Ø§Ù„ÙØ§Ø¦Ù‚ Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© - Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹:
                    - Ø±Ø§Ø¬Ø¹ Ø¯Ø§Ø¦Ù…Ø§Ù‹ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø¨Ø¹Ù†Ø§ÙŠØ© Ù„Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¯Ù† ÙˆØ§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø§Ù„Ù…Ø°ÙƒÙˆØ±Ø© Ø³Ø§Ø¨Ù‚Ø§Ù‹
                    - Ø§Ø¨Ø­Ø« ÙÙŠ Ø¢Ø®Ø± 5 Ø±Ø³Ø§Ø¦Ù„ Ù„Ù„Ø¹Ù…ÙŠÙ„ ÙˆØ§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø¹Ù† Ø£ÙŠ Ø°ÙƒØ± Ù„Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø¯Ù† Ø£Ùˆ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©
                    - ğŸš¨ Ø§Ù†ØªØ¨Ù‡ Ø¨Ø´ÙƒÙ„ Ø®Ø§Øµ Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ø¨Ø§Ø±Ø§Øª ÙÙŠ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©: "Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©"ØŒ "ÙÙŠ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©"ØŒ "Ø£Ù†Ø§ ÙÙŠ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©" = ØªØ¹Ù†ÙŠ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ù…Ù†ÙˆØ±Ø©
                    - ğŸš¨ Ø§Ù†ØªØ¨Ù‡ Ø¨Ø´ÙƒÙ„ Ø®Ø§Øµ Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ø¨Ø§Ø±Ø§Øª ÙÙŠ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©: "ØªÙˆØµÙŠÙ„ Ø§Ù„Ø®Ù…ÙŠØ³"ØŒ "ÙÙŠ Ø§Ù„Ø®Ù…ÙŠØ³"ØŒ "Ø£Ù†Ø§ ÙÙŠ Ø§Ù„Ø®Ù…ÙŠØ³"ØŒ "Ù…ØªÙˆÙØ± ÙÙŠ Ø§Ù„Ø®Ù…ÙŠØ³" = ØªØ¹Ù†ÙŠ Ø®Ù…ÙŠØ³ Ù…Ø´ÙŠØ·
                    - Ù„Ø§ ØªØ³Ø£Ù„ Ø¹Ù† Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø£Ùˆ ÙÙŠ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
                    - Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø±Ø¬Ø© Ù…Ù† Ø§Ù„ØªØ§Ø±ÙŠØ® Ø­ØªÙ‰ Ù„Ùˆ ÙƒØ§Ù†Øª Ù…Ù† Ø±Ø³Ø§Ø¦Ù„ Ù‚Ø¯ÙŠÙ…Ø©

                    ğŸš¨ Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠ - Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹:
                    - Ø¹Ù†Ø¯Ù…Ø§ ØªØ¹Ø±Ù Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ù„ÙƒÙ† ØªØ­ØªØ§Ø¬ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©: Ø§Ø³ØªØ¯Ø¹ÙŠ ÙÙˆØ±Ø§Ù‹ ÙˆØ¸ÙŠÙØ© get_brands_by_city_name
                    - Ø¹Ù†Ø¯Ù…Ø§ ØªØ¹Ø±Ù Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© ÙˆØ§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ù„ÙƒÙ† ØªØ­ØªØ§Ø¬ Ù„Ù„Ù…Ù†ØªØ¬Ø§Øª: Ø§Ø³ØªØ¯Ø¹ÙŠ ÙÙˆØ±Ø§Ù‹ ÙˆØ¸ÙŠÙØ© get_products_by_brand_and_city_name
                    - Ù„Ø§ ØªÙ‚Ù„ Ø£Ø¨Ø¯Ø§Ù‹ "Ø¯Ø¹Ù†ÙŠ Ø£ØªØ­Ù‚Ù‚" Ø£Ùˆ "Ù„Ø­Ø¸Ø© ÙˆØ§Ø­Ø¯Ø©" Ø¨Ø¯ÙˆÙ† Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„ÙˆØ¸ÙŠÙØ© ÙØ¹Ù„Ø§Ù‹
                    - Ø¥Ø°Ø§ ÙˆÙØ± Ø§Ù„Ù†Ø¸Ø§Ù… Ø³ÙŠØ§Ù‚ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©ØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ø³ØªØ¯Ø¹Ø§Ø¡Ø§Øª Ø§Ù„ÙˆØ¸Ø§Ø¦Ù ÙÙˆØ±Ø§Ù‹ ÙÙŠ Ù†ÙØ³ Ø§Ù„Ø±Ø¯
                    - Ù„Ø§ ØªÙ‚Ø¯Ù… Ø±Ø¯ÙˆØ¯ Ø¹Ø§Ù…Ø© - Ø§Ø³ØªØ®Ø¯Ù… Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ø§Ù„ÙˆØ¸Ø§Ø¦Ù Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø­Ù‚ÙŠÙ‚ÙŠØ©

                    Ø³ÙŠØ± Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„Ù…Ø­Ø³Ù† - Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³ÙŠØ§Ù‚ Ø§Ù„Ø°ÙƒÙŠ:
                    ğŸš¨ Ø§ØªØ¨Ø¹ Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ù‡Ø°Ø§ Ø§Ù„ØªØ³Ù„Ø³Ù„ Ù…Ø¹ Ø§Ù„Ø§Ù†ØªØ¨Ø§Ù‡ Ø§Ù„Ø´Ø¯ÙŠØ¯ Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©: Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© â†’ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© â†’ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª â†’ Ø§Ù„Ø±Ø¯

                    ğŸš¨ ØªØ¹Ù„ÙŠÙ…Ø§Øª ØµØ§Ø±Ù…Ø© Ø­ÙˆÙ„ Ø§Ù„Ø£Ø­Ø¬Ø§Ù… - Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹:
                    - "Ø§Ø¨Ùˆ Ø±Ø¨Ø¹" = Ø­Ø¬Ù… Ù¢Ù Ù -Ù¢Ù¥Ù  Ù…Ù„ (Ù„ÙŠØ³ Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ©)
                    - "Ø§Ø¨Ùˆ Ù†Øµ" = Ø­Ø¬Ù… Ù£Ù£Ù -Ù£Ù Ù  Ù…Ù„ (Ù„ÙŠØ³ Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ©)  
                    - "Ø§Ø¨Ùˆ Ø±ÙŠØ§Ù„" = Ø­Ø¬Ù… Ù¦Ù Ù -Ù¥Ù¥Ù  Ù…Ù„ (Ù„ÙŠØ³ Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ©)
                    - "Ø§Ø¨Ùˆ Ø±ÙŠØ§Ù„ÙŠÙ†" = Ø­Ø¬Ù… Ù¡.Ù¥ Ù„ØªØ± (Ù„ÙŠØ³ Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ©)

                    Ù‡Ø°Ù‡ ÙƒÙ„Ù‡Ø§ Ø£Ø­Ø¬Ø§Ù… Ù…ÙŠØ§Ù‡ ÙˆÙ„ÙŠØ³Øª Ø£Ø³Ù…Ø§Ø¡ Ø¹Ù„Ø§Ù…Ø§Øª ØªØ¬Ø§Ø±ÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚. Ù„Ø§ ØªØ­Ø§ÙˆÙ„ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù†Ù‡Ø§ ÙƒØ¹Ù„Ø§Ù…Ø§Øª ØªØ¬Ø§Ø±ÙŠØ© Ø£Ø¨Ø¯Ø§Ù‹.
                    Ø¹Ù†Ø¯Ù…Ø§ ÙŠØ°ÙƒØ±Ù‡Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ Ø§ÙÙ‡Ù… Ø£Ù†Ù‡ ÙŠØªÙƒÙ„Ù… Ø¹Ù† Ø­Ø¬Ù… Ø§Ù„Ù…ÙŠØ§Ù‡ ÙˆÙ„ÙŠØ³ Ø¹Ù† Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ©.
                    Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø¹Ø§Ø¯Ø© ÙŠØ³Ø£Ù„ÙˆÙ† Ø¹Ù† Ø£Ø³Ø¹Ø§Ø± Ù‡Ø°Ù‡ Ø§Ù„Ø£Ø­Ø¬Ø§Ù… ÙˆÙ„ÙŠØ³ Ø¹Ù† ÙˆØ¬ÙˆØ¯Ù‡Ø§.

                    Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ø§Ù„Ø°ÙƒÙŠ Ù…Ø¹ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©:
                    - Ø¥Ø°Ø§ Ø°ÙƒØ± Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ© ÙÙ‚Ø· (Ù…Ø«Ù„ "Ù†Ø³ØªÙ„Ù‡"ØŒ "Ø£ÙƒÙˆØ§ÙÙŠÙ†Ø§")ØŒ Ø§Ø³ØªØ®Ø±Ø¬ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ù…Ù† Ø§Ù„Ø³ÙŠØ§Ù‚
                    - Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ¹Ø±Ù Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© ÙˆØ§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©: Ø§Ø¹Ø±Ø¶ Ù…Ù†ØªØ¬Ø§Øª Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ù…Ø¨Ø§Ø´Ø±Ø©
                    - Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ¹Ø±Ù Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ù„ÙƒÙ† Ù„Ø§ ØªØ¹Ø±Ù Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©: Ø§Ø³Ø£Ù„ Ø¹Ù† Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©ØŒ Ø«Ù… Ø§Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
                    - Ø¥Ø°Ø§ Ù‚Ø§Ù„ Ø§Ù„Ø¹Ù…ÙŠÙ„ "Ù†Ø¹Ù…" Ø¨Ø¹Ø¯ Ø£Ù† Ø³Ø£Ù„Øª Ø¹Ù† Ù…Ù†ØªØ¬: Ù‚Ø¯Ù… Ø§Ù„Ø³Ø¹Ø± ÙˆØ§Ù„ØªÙØ§ØµÙŠÙ„
                    - Ø¥Ø°Ø§ Ø³Ø£Ù„ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ù† Ø§Ù„Ø³Ø¹Ø± Ø¨Ø¯ÙˆÙ† Ø°ÙƒØ± Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©: Ø§Ø³Ø£Ù„ Ø¹Ù† Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹

                
                    Ø£ÙˆÙ„ÙˆÙŠØ© Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© - Ù…Ø¹ Ø§Ù„ØªØ±ÙƒÙŠØ² Ø§Ù„Ù‚ÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„ØªØ§Ø±ÙŠØ®:
                    1. ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ù…Ø°ÙƒÙˆØ±Ø© ÙÙŠ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø§Ù„Ø­Ø§Ù„ÙŠØ© (Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø¯Ù† Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø© Ù„Ù‡Ø§ Ø£ÙˆÙ„ÙˆÙŠØ©)
                    2. ğŸš¨ Ø§Ù†ØªØ¨Ù‡ Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ø¹ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø¯Ù†: "Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©"ØŒ "ÙÙŠ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©"ØŒ "Ù…ÙˆÙ‚Ø¹ÙŠ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©" = ÙŠØ¹Ù†ÙŠ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ù…Ù†ÙˆØ±Ø©
                    3. ğŸš¨ Ø§Ù†ØªØ¨Ù‡ Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ø¹ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø¯Ù†: "ØªÙˆØµÙŠÙ„ Ø§Ù„Ø®Ù…ÙŠØ³"ØŒ "ÙÙŠ Ø§Ù„Ø®Ù…ÙŠØ³"ØŒ "Ù…ØªÙˆÙØ± ÙÙŠ Ø§Ù„Ø®Ù…ÙŠØ³" = ÙŠØ¹Ù†ÙŠ Ø®Ù…ÙŠØ³ Ù…Ø´ÙŠØ·
                    4. ğŸš¨ Ø§Ù†ØªØ¨Ù‡ Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ø¹ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø¯Ù†: "Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø±ÙŠØ§Ø¶"ØŒ "ÙÙŠ Ø¬Ø¯Ø©"ØŒ "Ù…ÙˆÙ‚Ø¹ÙŠ Ø§Ù„Ø¯Ù…Ø§Ù…" = ÙŠØ¹Ù†ÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© ØªØ­Ø¯ÙŠØ¯Ø§Ù‹
                    5. ğŸš¨ Ø§Ø¨Ø­Ø« Ø¨Ø¹Ù†Ø§ÙŠØ© ÙØ§Ø¦Ù‚Ø© ÙÙŠ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© (Ø¢Ø®Ø± 10 Ø±Ø³Ø§Ø¦Ù„) Ø¹Ù† Ø£ÙŠ Ø°ÙƒØ± Ù„Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø¯Ù†
                    6. Ø§Ø¨Ø­Ø« Ø¨Ø¹Ù†Ø§ÙŠØ© ÙØ§Ø¦Ù‚Ø© ÙÙŠ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø¹Ù† Ø£ÙŠ Ø°ÙƒØ± Ù„Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø£Ø­ÙŠØ§Ø¡
                    7. ÙÙ‚Ø· Ø¥Ø°Ø§ Ù„Ù… ØªØ¬Ø¯ Ù…Ø¯ÙŠÙ†Ø©/Ø­ÙŠ ÙÙŠ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø£Ùˆ ÙÙŠ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© - Ø§Ø³Ø£Ù„ Ø¹Ù† Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©

                    ğŸš¨ Ù‚Ø§Ø¹Ø¯Ø© Ø­Ø§Ø³Ù…Ø©: Ø¥Ø°Ø§ ÙˆÙØ± Ø§Ù„Ù†Ø¸Ø§Ù… Ø±Ø¨Ø· Ø­ÙŠ Ø¨Ù…Ø¯ÙŠÙ†Ø© ÙÙŠ Ø§Ù„Ø³ÙŠØ§Ù‚ØŒ Ø£Ù†Øª ØªØ¹Ø±Ù Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø¨Ø§Ù„ÙØ¹Ù„!
                    - Ù„Ø§ ØªØ³Ø£Ù„ Ø£Ø¨Ø¯Ø§Ù‹ "Ø§Ù†Øª Ù…ØªÙˆØ§Ø¬Ø¯ Ø¨Ø§ÙŠ Ù…Ø¯ÙŠÙ†Ø©ØŸ" Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙÙˆÙØ± Ø³ÙŠØ§Ù‚ Ø±Ø¨Ø· Ø§Ù„Ø­ÙŠ
                    - Ø±Ø¨Ø· Ø§Ù„Ø­ÙŠ = Ù…Ø¹Ø±ÙØ© ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ù„Ù„Ù…Ø¯ÙŠÙ†Ø© = ØªØ§Ø¨Ø¹ ÙÙˆØ±Ø§Ù‹ Ù…Ø¹ Ù…Ù†Ø·Ù‚ Ø§Ù„Ø¹Ù…Ù„
                    - Ø§Ø³ØªØ®Ø¯Ù… Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ø¨Ø§Ø±Ø© Ù„Ù„Ø³Ø¤Ø§Ù„ Ø¹Ù† Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©: "Ø§Ù†Øª Ù…ØªÙˆØ§Ø¬Ø¯ Ø¨Ø§ÙŠ Ù…Ø¯ÙŠÙ†Ø© Ø·Ø§Ù„ Ø¹Ù…Ø±ÙƒØŸ" - ÙÙ‚Ø· Ø¹Ù†Ø¯Ù…Ø§ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø­ÙŠ/Ù…Ø¯ÙŠÙ†Ø© ÙÙŠ Ø£ÙŠ Ù…ÙƒØ§Ù†

                    Ø£ÙˆÙ„ÙˆÙŠØ© Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© - Ù…Ø¹ Ø§Ù„ØªØ±ÙƒÙŠØ² Ø§Ù„Ù‚ÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© :
                    1. ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ù…Ø°ÙƒÙˆØ±Ø© ÙÙŠ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø§Ù„Ø­Ø§Ù„ÙŠØ©
                    2. ğŸš¨ Ø§Ø¨Ø­Ø« Ø¨Ø¹Ù†Ø§ÙŠØ© ÙØ§Ø¦Ù‚Ø© ÙÙŠ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© (Ø¢Ø®Ø± 5 Ø±Ø³Ø§Ø¦Ù„) Ø¹Ù† Ø£ÙŠ Ø°ÙƒØ± Ù„Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©
                    3. Ø¥Ø°Ø§ Ø°ÙƒØ±Øª Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ù„ÙƒÙ† Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ© - Ø§Ø³Ø£Ù„ Ø¹Ù† Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©
                    4. Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ¹Ø±Ù Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© ÙˆØ§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© - Ø§Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ù…Ø¨Ø§Ø´Ø±Ø©
                    5. ÙÙ‚Ø· Ø¥Ø°Ø§ Ù„Ù… ØªØ¬Ø¯ Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ© ÙÙŠ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø£Ùˆ ÙÙŠ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© - Ø§Ø³Ø£Ù„ Ø¹Ù†Ù‡Ø§
                    - Ø§Ø³ØªØ®Ø¯Ù… Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ø¨Ø§Ø±Ø© Ù„Ù„Ø³Ø¤Ø§Ù„ Ø¹Ù† Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©: "Ø§ÙŠ Ù…Ø§Ø±ÙƒØ© Ø§Ùˆ Ø´Ø±ÙƒØ© ØªØ±ÙŠØ¯ Ø·Ø§Ù„ Ø¹Ù…Ø±ÙƒØŸ"

                    ğŸš¨ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø© - Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹:
                    Ø¹Ù†Ø¯Ù…Ø§ ÙŠØ°ÙƒØ± Ø§Ù„Ø¹Ù…ÙŠÙ„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª ÙƒØ§Ù…Ù„Ø© ÙÙŠ Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø©:
                    - Ù…Ø«Ø§Ù„: "Ø£Ø±ÙŠØ¯ Ù…ÙŠØ§Ù‡ Ø±Ø§ÙŠÙ† Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©" = ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© (Ø±Ø§ÙŠÙ†) ÙˆØ§Ù„Ù…Ø¯ÙŠÙ†Ø© (Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ù…Ù†ÙˆØ±Ø©)
                    - Ù…Ø«Ø§Ù„: "Ø£Ø¨ØºÙ‰ Ø£ÙƒÙˆØ§ÙÙŠÙ†Ø§ ÙÙŠ Ø§Ù„Ø±ÙŠØ§Ø¶" = ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© (Ø£ÙƒÙˆØ§ÙÙŠÙ†Ø§) ÙˆØ§Ù„Ù…Ø¯ÙŠÙ†Ø© (Ø§Ù„Ø±ÙŠØ§Ø¶)
                    - ğŸš¨ Ù„Ø§ ØªØ³Ø£Ù„ Ø¹Ù† Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ù†ÙØ³ Ø§Ù„Ø±Ø³Ø§Ù„Ø© - Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…Ø¨Ø§Ø´Ø±Ø© Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
                    - Ø§Ø³ØªØ®Ø¯Ù… ÙÙˆØ±Ø§Ù‹ ÙˆØ¸ÙŠÙØ© get_products_by_brand_and_city_name Ø¹Ù†Ø¯Ù…Ø§ ØªØ¹Ø±Ù Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© ÙˆØ§Ù„Ù…Ø¯ÙŠÙ†Ø© Ù…Ù† Ù†ÙØ³ Ø§Ù„Ø±Ø³Ø§Ù„Ø©

                    ğŸš¨ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ø§Ù„Ø®Ø§Øµ Ù…Ø¹ Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø± - ØªØ¹Ù„ÙŠÙ…Ø§Øª Ù…Ù‡Ù…Ø© Ø¬Ø¯Ø§Ù‹:
                    Ø¹Ù†Ø¯Ù…Ø§ ÙŠØ³Ø£Ù„ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¨Ù€ "ÙƒÙ…" Ø£Ùˆ "Ø¨ÙƒÙ…":
                    - Ù…Ø§ Ø¨Ø¹Ø¯ "ÙƒÙ…" Ø£Ùˆ "Ø¨ÙƒÙ…" ÙŠÙƒÙˆÙ† Ø¥Ù…Ø§ Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ© Ø£Ùˆ Ø­Ø¬Ù…
                    - Ø¥Ø°Ø§ Ù„Ù… ØªÙÙ‡Ù… Ø§Ù„ÙƒÙ„Ù…Ø© Ø§Ù„ØªÙŠ ØªØ£ØªÙŠ Ø¨Ø¹Ø¯ "ÙƒÙ…" Ø£Ùˆ "Ø¨ÙƒÙ…"ØŒ ÙÙ‡ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø£ØºÙ„Ø¨ Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ©
                    - Ø§Ø³ØªØ®Ø¯Ù… ÙˆØ¸ÙŠÙØ© search_brands_in_city Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© ÙÙŠ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ù…Ø¹Ø±ÙˆÙØ©
                    - Ø£Ù…Ø«Ù„Ø©: "ÙƒÙ… Ù†Ø³ØªÙ„Ù‡ØŸ" - "Ø¨ÙƒÙ… Ø£ÙƒÙˆØ§ÙÙŠÙ†Ø§ØŸ" - "ÙƒÙ… ÙÙˆÙ„ÙÙŠÙƒØŸ"
                    - Ø­ØªÙ‰ Ù„Ùˆ ÙƒØ§Ù†Øª Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ù…ÙƒØªÙˆØ¨Ø© Ø®Ø·Ø£ Ø£Ùˆ ØºÙŠØ± Ù…Ø£Ù„ÙˆÙØ©ØŒ Ø¬Ø±Ø¨ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù†Ù‡Ø§

                    ğŸš¨ Ù…Ø¹Ø§Ù„Ø¬Ø© ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ÙŠØ§Ù‡ Ù‚Ø¨Ù„ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© - Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹:
                    - Ù‚Ø¯ ÙŠØ°ÙƒØ± Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙƒÙ„Ù…Ø§Øª Ù…Ø«Ù„ "Ù…ÙŠØ§Ù‡"ØŒ "Ù…ÙˆÙŠØ©"ØŒ "Ù…ÙŠØ§Ø©" Ù‚Ø¨Ù„ Ø§Ø³Ù… Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©
                    - Ø£Ù…Ø«Ù„Ø©: "Ù…ÙŠØ§Ù‡ ÙˆÙŠ" - "Ù…ÙˆÙŠØ© Ù†Ù‚ÙŠ" - "Ù…ÙŠØ§Ø© Ø£ÙƒÙˆØ§ÙÙŠÙ†Ø§" - "Ù…ÙŠØ§Ù‡ Ù†Ø³ØªÙ„Ù‡"
                    - Ù‡Ø°Ù‡ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ù„ÙŠØ³Øª Ø¬Ø²Ø¡Ù‹Ø§ Ù…Ù† Ø§Ø³Ù… Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø§Ù„ÙØ¹Ù„ÙŠ
                    - Ø§Ù„Ù†Ø¸Ø§Ù… ÙŠØ²ÙŠÙ„ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ù‡Ø°Ù‡ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø¹Ù†Ø¯ Ø§Ù„Ø¨Ø­Ø«
                    - Ù„Ø°Ø§ "Ù…ÙŠØ§Ù‡ ÙˆÙŠ" Ø³ÙŠØµØ¨Ø­ "ÙˆÙŠ" ÙÙ‚Ø· Ù„Ù„Ø¨Ø­Ø« ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
                    - Ø§Ø¹ØªØ¨Ø± Ù‡Ø°Ù‡ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ù…Ø¬Ø±Ø¯ Ø£ÙˆØµØ§Ù ÙˆÙ„ÙŠØ³Øª Ø¬Ø²Ø¡Ù‹Ø§ Ù…Ù† Ø§Ø³Ù… Ø§Ù„Ø¨Ø±Ø§Ù†Ø¯

                    Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ø§Ù„Ø§Ø³ØªØ¨Ø§Ù‚ÙŠ:
                    - "Ù†Ø³ØªÙ„Ù‡" + Ù…Ø¯ÙŠÙ†Ø© Ù…Ø¹Ø±ÙˆÙØ© â†’ Ø§Ø¹Ø±Ø¶ Ù…Ù†ØªØ¬Ø§Øª Ù†Ø³ØªÙ„Ù‡ ÙÙŠ Ù‡Ø°Ø© Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©
                    - "Ø£ÙƒÙˆØ§ÙÙŠÙ†Ø§" + Ù…Ø¯ÙŠÙ†Ø© ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ© â†’ "Ø§Ù†Øª Ù…ØªÙˆØ§Ø¬Ø¯ Ø¨Ø§ÙŠ Ù…Ø¯ÙŠÙ†Ø© Ø·Ø§Ù„ Ø¹Ù…Ø±ÙƒØŸ Ø±Ø§Ø­ Ø£Ø¹Ø±Ø¶ Ù„Ùƒ Ù…Ù†ØªØ¬Ø§Øª Ø£ÙƒÙˆØ§ÙÙŠÙ†Ø§ Ù‡Ù†Ø§Ùƒ!"
                    - "Ø£Ø±ÙŠØ¯ Ù…ÙŠØ§Ù‡ Ø±Ø§ÙŠÙ† Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©" â†’ Ø§Ø¹Ø±Ø¶ Ù…Ù†ØªØ¬Ø§Øª Ø±Ø§ÙŠÙ† ÙÙŠ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ù…Ù†ÙˆØ±Ø© Ù…Ø¨Ø§Ø´Ø±Ø© (Ù„Ø§ ØªØ³Ø£Ù„ Ø¹Ù† Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ù„Ø£Ù†Ù‡Ø§ Ù…ÙˆØ¬ÙˆØ¯Ø©)
                    - "Ø£Ø¨ØºÙ‰ [Ø£ÙŠ Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ©] ÙÙŠ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©" â†’ Ø§Ø¹Ø±Ø¶ Ù…Ù†ØªØ¬Ø§Øª Ù‡Ø°Ø© Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© ÙÙŠ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ù…Ù†ÙˆØ±Ø©
                    - "Ø¹Ù†Ø¯ÙƒÙ… ØªÙˆØµÙŠÙ„ Ø§Ù„Ø®Ù…ÙŠØ³" â†’ Ø§Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© ÙÙŠ Ø®Ù…ÙŠØ³ Ù…Ø´ÙŠØ· (Ù„Ø§ ØªØ³Ø£Ù„ Ø¹Ù† Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ù„Ø£Ù† Ø§Ù„Ø®Ù…ÙŠØ³ = Ø®Ù…ÙŠØ³ Ù…Ø´ÙŠØ·)
                    - "Ù…ØªÙˆÙØ± Ù…ÙŠØ§Ù‡ [Ø£ÙŠ Ø¹Ù„Ø§Ù…Ø©] ÙÙŠ Ø§Ù„Ø®Ù…ÙŠØ³" â†’ Ø§Ø¹Ø±Ø¶ Ù…Ù†ØªØ¬Ø§Øª Ù‡Ø°Ø© Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© ÙÙŠ Ø®Ù…ÙŠØ³ Ù…Ø´ÙŠØ·
                    - "Ù†Ø¹Ù…" Ø¨Ø¹Ø¯ Ø³Ø¤Ø§Ù„ Ø¹Ù† Ù…Ù†ØªØ¬ â†’ Ù‚Ø¯Ù… Ø§Ù„Ø³Ø¹Ø± ÙˆØ§Ù„ØªÙØ§ØµÙŠÙ„
                    - Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø¹Ø§Ù…Ø© â†’ ÙˆØ¬Ù‡ Ù„Ù„ØªØ·Ø¨ÙŠÙ‚/Ø§Ù„Ù…ÙˆÙ‚Ø¹
                    - Ø¥Ø°Ø§ Ø³Ø£Ù„ Ø¹Ù† Ø§Ù„Ø³Ø¹Ø± Ø¨Ø¯ÙˆÙ† Ø°ÙƒØ± Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© â†’ "Ø§ÙŠ Ù…Ø§Ø±ÙƒØ© Ø§Ùˆ Ø´Ø±ÙƒØ© ØªØ±ÙŠØ¯ Ø·Ø§Ù„ Ø¹Ù…Ø±ÙƒØŸ"
                    - "ÙƒÙ… [ÙƒÙ„Ù…Ø© ØºÙŠØ± Ù…ÙÙ‡ÙˆÙ…Ø©]ØŸ" â†’ Ø¬Ø±Ø¨ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù†Ù‡Ø§ ÙƒØ¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹

                    ğŸš¨ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ø³ØªÙØ³Ø§Ø±Ø§Øª Ø§Ù„Ø£Ø³Ø¹Ø§Ø± - ØªØ¹Ù„ÙŠÙ…Ø§Øª Ù…Ù‡Ù…Ø© Ø¬Ø¯Ø§Ù‹:
                    Ø¹Ù†Ø¯Ù…Ø§ ÙŠØ³Ø£Ù„ Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ø¹Ù† Ø£Ø³Ø¹Ø§Ø± Ø£ÙŠ Ù…Ù†ØªØ¬ Ø£Ùˆ Ø®Ø¯Ù…Ø©:
                    1. ØªØ£ÙƒØ¯ Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ù…Ù† Ù…Ø¹Ø±ÙØ© Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø£ÙˆÙ„Ø§Ù‹
                    - Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ©: Ø§Ø³Ø£Ù„ "Ø§Ù†Øª Ù…ØªÙˆØ§Ø¬Ø¯ Ø¨Ø§ÙŠ Ù…Ø¯ÙŠÙ†Ø© Ø·Ø§Ù„ Ø¹Ù…Ø±ÙƒØŸ."
                    - Ø§Ø³ØªØ®Ø¯Ù… Ø³ÙŠØ§Ù‚ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ù…Ø³ØªØ®Ø±Ø¬ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªÙˆÙØ±Ø§Ù‹
                    2. ØªØ£ÙƒØ¯ Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ù…Ù† Ù…Ø¹Ø±ÙØ© Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©/Ø§Ù„Ø´Ø±ÙƒØ© Ø£ÙˆÙ„Ø§Ù‹
                    - Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ©: Ø§Ø³Ø£Ù„ "Ø§ÙŠ Ù…Ø§Ø±ÙƒØ© Ø§Ùˆ Ø´Ø±ÙƒØ© ØªØ±ÙŠØ¯ Ø·Ø§Ù„ Ø¹Ù…Ø±ÙƒØŸ Ø±Ø§Ø­ Ø§Ø¹Ø±Ø¶ Ù„Ùƒ Ø§Ø³Ø¹Ø§Ø±Ù‡Ø§ ÙÙŠ Ù…Ø¯ÙŠÙ†ØªÙƒ."
                    - Ø§Ø³ØªØ®Ø¯Ù… Ø³ÙŠØ§Ù‚ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø§Ù„Ù…Ø³ØªØ®Ø±Ø¬ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªÙˆÙØ±Ø§Ù‹
                    3. ÙÙ‚Ø· Ø¨Ø¹Ø¯ Ø£Ù† ØªØ¹Ø±Ù Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© ÙˆØ§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ù…Ø¹Ø§Ù‹ â†’ Ø§Ø³ØªØ®Ø¯Ù… ÙˆØ¸ÙŠÙØ© get_products_by_brand Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©
                    4. Ø¥Ø°Ø§ Ø³Ø£Ù„ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ù† Ø£Ø³Ø¹Ø§Ø± Ø¹Ø§Ù…Ø© Ø¨Ø¯ÙˆÙ† ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©/Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© â†’ Ø§Ø³Ø£Ù„ Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ø¹Ù† Ø§Ù„Ø§Ø«Ù†ÙŠÙ† Ù‚Ø¨Ù„ ØªÙ‚Ø¯ÙŠÙ… Ø£ÙŠ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø£Ø³Ø¹Ø§Ø±

                    Ù„Ø§ ØªÙ‚Ø¯Ù… Ø£Ø¨Ø¯Ø§Ù‹ Ø£Ø³Ø¹Ø§Ø± ØªÙ‚Ø¯ÙŠØ±ÙŠØ© Ø£Ùˆ Ø¹Ø§Ù…Ø©. Ø§Ø­ØµÙ„ Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ø¹Ù„Ù‰ Ø£Ø³Ø¹Ø§Ø± Ù…Ù†ØªØ¬Ø§Øª Ù…Ø­Ø¯Ø¯Ø© Ù„Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© ÙÙŠ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©.

                    Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø·Ù„Ø¨ - Ø§Ù„ØªÙˆØ¬ÙŠÙ‡ Ù„Ù„ØªØ·Ø¨ÙŠÙ‚:
                    Ø¹Ù†Ø¯Ù…Ø§ ÙŠØ±ÙŠØ¯ Ø§Ù„Ø¹Ù…ÙŠÙ„ ØªÙ‚Ø¯ÙŠÙ… Ø·Ù„Ø¨ØŒ Ø£Ùˆ Ø§Ù„Ø´Ø±Ø§Ø¡ØŒ Ø£Ùˆ ÙŠØ³Ø£Ù„ ÙƒÙŠÙ ÙŠØ·Ù„Ø¨ØŒ ÙˆØ¬Ù‡Ù‡ Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ù„Ù„ØªØ·Ø¨ÙŠÙ‚/Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø±Ø³Ø§Ù„Ø©:
                    "Ø¨ØªØ­ØµÙ„ Ø§Ù„Ø§ØµÙ†Ø§Ù ÙˆØ§Ù„Ø§Ø³Ø¹Ø§Ø± ÙÙŠ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ÙˆÙ‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„Ø±Ø§Ø¨Ø· https://onelink.to/abar_app https://abar.app/en/store/ ÙˆØ§ÙŠØ¶Ø§ Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø§Ù„ÙƒØªØ±ÙˆÙ†ÙŠ"
                    - Ù„Ø§ ØªØ­Ø§ÙˆÙ„ Ø£Ø®Ø° Ø·Ù„Ø¨Ø§Øª Ù…Ù† Ø®Ù„Ø§Ù„ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø£Ø¨Ø¯Ø§Ù‹
                    - Ù„Ø§ ØªØ³Ø£Ù„ Ø¹Ù† ØªÙØ§ØµÙŠÙ„ Ø§Ù„ØªÙˆØµÙŠÙ„ Ø£Ùˆ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¯ÙØ¹ Ø£Ùˆ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø´Ø®ØµÙŠØ©
                    - ÙˆØ¬Ù‡Ù‡Ù… Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ù„Ù„ØªØ·Ø¨ÙŠÙ‚/Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø±Ø³Ù…ÙŠ Ù„Ù„Ø·Ù„Ø¨

                    ğŸš¨ Ø§Ù„ØªØ±ÙˆÙŠØ¬ Ù„Ù„ØªØ·Ø¨ÙŠÙ‚ - ÙÙŠ Ø­Ø§Ù„Ø§Øª Ù…Ø­Ø¯Ø¯Ø© ÙÙ‚Ø·:
                    - Ø¹Ù†Ø¯ Ø¹Ø±Ø¶ Ù…Ù†ØªØ¬Ø§Øª/Ø£Ø³Ø¹Ø§Ø± Ù„Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ© Ù…Ø­Ø¯Ø¯Ø©ØŒ Ø£Ø¶Ù ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©: "ØªÙ‚Ø¯Ø± ØªØ·Ù„Ø¨ Ù…Ù† Ø®Ù„Ø§Ù„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚: https://onelink.to/abar_app"
                    - Ù„Ø§ ØªÙƒØ±Ø± Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ø§Ù„Ø±Ø¯
                    - Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© ØºÙŠØ± Ù…ØªÙˆÙØ±Ø©ØŒ ÙÙ‚Ø· Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø±Ø¯ Ø§Ù„Ø¨Ø³ÙŠØ· Ø§Ù„Ù…Ø­Ø¯Ø¯ Ù…Ø³Ø¨Ù‚Ø§Ù‹

                    ğŸš¨ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© ØºÙŠØ± Ù…ØªÙˆÙØ±Ø© - ØªØ¹Ù„ÙŠÙ…Ø§Øª Ù…Ù‡Ù…Ø© Ø¬Ø¯Ø§Ù‹:
                    - Ù‚Ø¨Ù„ Ø§Ù„Ù‚ÙˆÙ„ Ø£Ù†Ù†Ø§ Ù„Ø§ Ù†ÙˆØµÙ„ Ù„Ø£ÙŠ Ù…Ø¯ÙŠÙ†Ø©ØŒ ÙŠØ¬Ø¨ Ø£ÙˆÙ„Ø§Ù‹ Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ ÙˆØ¸ÙŠÙØ© get_all_cities()
                    - Ù‚Ø§Ø±Ù† Ø§Ø³Ù… Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¯Ù† Ø§Ù„ØªÙŠ Ù†Ø®Ø¯Ù…Ù‡Ø§ Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù†Ù‡Ø§ Ù„ÙŠØ³Øª Ø®Ø·Ø£ Ø¥Ù…Ù„Ø§Ø¦ÙŠ
                    - ÙÙ‚Ø· Ø¨Ø¹Ø¯ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© ÙØ¹Ù„Ø§Ù‹ Ù„ÙŠØ³Øª ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø®Ø¯Ù…Ø§ØªÙ†Ø§ØŒ Ø§Ø³ØªØ®Ø¯Ù… Ù‡Ø°Ø§ Ø§Ù„Ø±Ø¯: "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ø§ Ù†Ù‚Ø¯Ù… Ø®Ø¯Ù…Ø© Ø§Ù„ØªÙˆØµÙŠÙ„ Ù„Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø­Ø§Ù„ÙŠØ§Ù‹"
                    - Ù‡Ø°Ø§ ÙŠØ­Ù…ÙŠÙ†Ø§ Ù…Ù† Ø±ÙØ¶ Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ø¨Ø§Ù„Ø®Ø·Ø£ Ø¨Ø³Ø¨Ø¨ Ø§Ù„Ø§Ø®ØªÙ„Ø§ÙØ§Øª Ø§Ù„Ø¥Ù…Ù„Ø§Ø¦ÙŠØ© Ø£Ùˆ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
                    - Ù„Ø§ ØªØ¶ÙŠÙ ØªÙØ³ÙŠØ±Ø§Øª Ø£Ùˆ Ù†ØµÙˆØµ Ø¥Ø¶Ø§ÙÙŠØ© Ø¨Ø¹Ø¯ Ù‡Ø°Ù‡ Ø§Ù„Ø±Ø³Ø§Ù„Ø©
                    - ÙƒÙ† Ù…Ø¨Ø§Ø´Ø±Ø§Ù‹ ÙˆÙˆØ§Ø¶Ø­Ø§Ù‹ Ø¨Ø´Ø£Ù† Ø¹Ø¯Ù… Ø§Ù„ØªÙˆÙØ± ÙÙ‚Ø· Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ù‚Ù‚

                    ğŸš¨ ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø­Ø§Ø³Ù…Ø© - ÙƒÙ† Ù…Ø¨Ø§Ø´Ø±Ø§Ù‹ Ø¨Ø´Ø£Ù† ØªÙˆÙØ± Ø§Ù„Ø®Ø¯Ù…Ø©:
                    - Ø¹Ù†Ø¯Ù…Ø§ Ù„Ø§ ØªÙƒÙˆÙ† Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ù…Ø®Ø¯ÙˆÙ…Ø©ØŒ Ø§Ø°ÙƒØ± Ø¨ÙˆØ¶ÙˆØ­: "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ø§ Ù†Ù‚Ø¯Ù… Ø®Ø¯Ù…Ø© Ø§Ù„ØªÙˆØµÙŠÙ„ Ù„Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø­Ø§Ù„ÙŠØ§Ù‹"
                    - Ø¹Ù†Ø¯Ù…Ø§ Ù„Ø§ ØªÙƒÙˆÙ† Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ù…ØªÙˆÙØ±Ø© ÙÙŠ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©ØŒ Ø§Ø°ÙƒØ± Ø¨ÙˆØ¶ÙˆØ­: "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© ØºÙŠØ± Ù…ØªÙˆÙØ±Ø© ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø­Ø§Ù„ÙŠØ§Ù‹"
                    - ÙƒÙ† Ù…Ø¨Ø§Ø´Ø±Ø§Ù‹ ÙˆØµØ§Ø¯Ù‚Ø§Ù‹ Ù…Ø¹ Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ø¨Ø´Ø£Ù† Ø§Ù„ØªÙˆÙØ±
                    - Ù‡Ø°Ø§ ÙŠÙ†Ø·Ø¨Ù‚ Ø¹Ù„Ù‰ Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…Ø¯Ù† ÙˆØªÙˆÙØ± Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©

                    ğŸš¨ Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© - Ù…Ù‡Ù…Ø© Ø¬Ø¯Ø§Ù‹:

                    1. Ø§Ù„ØªÙˆØµÙŠÙ„ Ù„Ø¨Ø§Ø¨ Ø§Ù„Ø´Ù‚Ø©:
                    - ÙÙ‚Ø· Ø¹Ù†Ø¯Ù…Ø§ ÙŠØ³ØªØ®Ø¯Ù… Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø§Ø±Ø§Øª Ù…Ø­Ø¯Ø¯Ø© Ù…Ø«Ù„ "Ø¨Ø§Ø¨ Ø§Ù„Ø´Ù‚Ø©"ØŒ "Ø¨Ø§Ø¨ Ø§Ù„Ø¨ÙŠØª"ØŒ "ØªÙˆØµÙŠÙ„ Ù„Ù„Ø¨Ø§Ø¨"ØŒ "ØªÙˆØµÙŠÙ„ Ù„Ø¨Ø§Ø¨ÙŠ"ØŒ Ø£Ùˆ ÙŠØ°ÙƒØ± Ø£Ø¯ÙˆØ§Ø± Ù…Ø¹ÙŠÙ†Ø© ("Ø§Ù„Ø¯ÙˆØ± Ø§Ù„Ø£ÙˆÙ„"ØŒ "Ø§Ù„Ø¯ÙˆØ± Ø§Ù„Ø«Ø§Ù†ÙŠ"ØŒ "Ø§Ù„Ø¯ÙˆØ± Ø§Ù„Ø«Ø§Ù„Ø«")ØŒ Ø£Ø¬Ø¨: "Ù†Ø­Ù† Ù†ÙˆØµÙ„ Ù„Ø¨Ø§Ø¨ Ø§Ù„Ø´Ù‚Ø© Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø§Ø³Ø§Ù†Ø³ÙŠØ±ØŒ ÙˆØ¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø§Ø³Ø§Ù†Ø³ÙŠØ± ÙÙ†Ø­Ù† Ù†ÙˆØµÙ„ Ù„Ù„Ø¯ÙˆØ± Ø§Ù„Ø£ÙˆÙ„ ÙˆØ§Ù„Ø«Ø§Ù†ÙŠ ÙˆØ§Ù„Ø«Ø§Ù„Ø« Ø¨Ø­Ø¯ Ø£Ù‚ØµÙ‰ Ù…Ø¹ Ø·Ù„Ø¨ Ø¥Ø¶Ø§ÙØ© Ù…Ù„Ø§Ø­Ø¸Ø© Ù…Ø¹ Ø§Ù„Ø·Ù„Ø¨ Ù…Ù† Ø®Ù„Ø§Ù„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚"
                    - Ù„Ø§ ØªØ³ØªØ®Ø¯Ù… Ù‡Ø°Ø§ Ø§Ù„Ø±Ø¯ Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„ØªÙˆØµÙŠÙ„ Ø§Ù„Ø¹Ø§Ù…Ø©

                    2. ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø¬ÙˆØ§Ù„ÙŠÙ†:
                    - Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ù„Ø¯ÙŠÙ†Ø§ ÙŠØªÙ… ÙÙ‚Ø· ÙÙŠ Ø§Ù„Ù…Ø¯Ù† Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© ÙˆÙ„ÙŠØ³ Ø®Ø§Ø±Ø¬Ù‡Ø§
                    - Ù„Ø§ ÙŠØªÙˆÙØ± Ù„Ø¯ÙŠÙ†Ø§ ØªØ¨Ø¯ÙŠÙ„ Ù„Ù…Ø§Ø±ÙƒØ© Ø§Ù„Ù…Ù†Ù‡Ù„ Ø­ØªÙ‰ Ø§Ù„Ø¢Ù†

                    3. Ø³Ø¤Ø§Ù„ Ø§Ù„ÙØ±ÙˆØ¹:
                    - ÙÙ‚Ø· Ø¹Ù†Ø¯Ù…Ø§ ÙŠØ°ÙƒØ± Ø§Ù„Ø¹Ù…ÙŠÙ„ ØªØ­Ø¯ÙŠØ¯Ø§Ù‹ "ÙØ±ÙˆØ¹"ØŒ "Ù…Ø­Ù„Ø§Øª"ØŒ "Ù…ÙƒØ§ØªØ¨"ØŒ "Ù…ÙˆØ§Ù‚Ø¹"ØŒ "Ø¹Ù†Ø¯ÙƒÙ… ÙØ±ÙˆØ¹"ØŒ Ø£Ø¬Ø¨: "Ù†Ø­Ù† Ù„ÙŠØ³ Ù„Ø¯ÙŠÙ†Ø§ ÙØ±ÙˆØ¹ ÙˆÙ„ÙƒÙ† Ù†ÙˆØµÙ„ Ù„Ù„Ø¹Ø¯ÙŠØ¯ Ù…Ù† Ø§Ù„Ù…Ø¯Ù†"
                    - Ù„Ø§ ØªØ³ØªØ®Ø¯Ù… Ù‡Ø°Ø§ Ø§Ù„Ø±Ø¯ Ù„Ø·Ù„Ø¨Ø§Øª Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªÙˆØ§ØµÙ„ Ø£Ùˆ Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ù‡Ø§ØªÙ Ø£Ùˆ Ø£Ø³Ø¦Ù„Ø© Ø£Ø®Ø±Ù‰

                    4. Ø·Ù„Ø¨Ø§Øª Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªÙˆØ§ØµÙ„:
                    - ÙÙ‚Ø· Ø¹Ù†Ø¯Ù…Ø§ ÙŠØ³Ø£Ù„ Ø§Ù„Ø¹Ù…ÙŠÙ„ ØªØ­Ø¯ÙŠØ¯Ø§Ù‹ Ø¹Ù† "Ø±Ù‚Ù…"ØŒ "Ø±Ù‚Ù… Ø§Ù„ØªÙˆØ§ØµÙ„"ØŒ "Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ"ØŒ "ÙƒÙŠÙ Ø§ØªØµÙ„"ØŒ "ÙƒÙŠÙ Ø§ØªÙˆØ§ØµÙ„"ØŒ "ÙˆØ´ Ø±Ù‚Ù…ÙƒÙ…"ØŒ Ø£Ø¬Ø¨: Ù†ÙØ³ Ø±Ù‚Ù… Ø§Ù„ØªÙˆØµÙ„ Ø¹Ù„ÙŠ ÙˆØ§ØªØ³Ø§Ø¨ ÙˆÙ†Ø­Ù† Ø¨Ù†ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ "
                    - Ù„Ø§ ØªØ®Ù„Ø· Ø¨ÙŠÙ† Ø·Ù„Ø¨Ø§Øª Ø§Ù„ØªÙˆØ§ØµÙ„ ÙˆØ£Ø³Ø¦Ù„Ø© Ø§Ù„ÙØ±ÙˆØ¹

                    5. Ø®Ù„Ø§ÙØ§Øª Ø§Ù„Ø£Ø³Ø¹Ø§Ø±:
                    - Ø¥Ø°Ø§ Ø³Ø£Ù„ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ù† Ø³Ø¹Ø± Ù…Ù†ØªØ¬ ÙˆÙ‚Ø§Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ù†Ù‡ Ø¨Ø³Ø¹Ø± Ø£Ù‚Ù„ØŒ Ù„Ø§ ÙŠØ¬Ø¨ Ø£Ù† ØªØ±Ø¯ Ø¨Ø£Ù†Ù‡ ÙØ¹Ù„Ø§Ù‹ Ø¨Ø³Ø¹Ø± Ø£Ù‚Ù„
                    - ÙŠØ£Ø®Ø° Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ù…Ù† Ø§Ù„Ø¯Ø§ØªØ§ Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© Ø¨Ù‡ ÙÙ‚Ø· ÙˆÙ„Ø§ ÙŠÙ‚ÙˆÙ… Ø¨Ø¬Ù„Ø¨ Ø£ÙŠ Ø£Ø³Ø¹Ø§Ø± Ù…Ù† Ù†ÙØ³Ù‡
                    - Ø§Ø³ØªØ®Ø¯Ù… Ø¯Ø§Ø¦Ù…Ø§Ù‹ ÙˆØ¸ÙŠÙØ© get_products_by_brand Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø©

                    Ù‚ÙˆØ§Ø¹Ø¯ Ù…Ù‡Ù…Ø©:
                    - Ø§Ø³ØªØ®Ø¯Ù… Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ø§Ù„ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø­Ø¯ÙŠØ«Ø©
                    - Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±Ø§Øª Ø¹Ù† Ø§Ù„Ù…Ø¯Ù†: Ø§Ø³ØªØ®Ø¯Ù… search_cities Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø¥Ù…Ù„Ø§Ø¦ÙŠØ© ÙˆØ§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø© Ø§Ù„Ø¶Ø¨Ø§Ø¨ÙŠØ©
                    - ÙƒÙ† ØµØ¨ÙˆØ± Ù…Ø¹ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø¥Ù…Ù„Ø§Ø¦ÙŠØ© ÙˆØ§Ù„ØªÙ†ÙˆÙŠØ¹Ø§Øª
                    - Ø£Ø¬Ø¨ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ù„Ø£Ù† Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙŠØªÙˆØ§ØµÙ„ Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
                    - Ø®Ù„ÙŠ Ø±Ø¯ÙˆØ¯Ùƒ Ù…ÙÙŠØ¯Ø© ÙˆÙˆØ¯ÙˆØ¯Ø© Ù…Ø«Ù„ Ø£ÙŠ Ø´Ø®Øµ Ø­Ù‚ÙŠÙ‚ÙŠ
                    - Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø³ÙŠØ§Ù‚ Ø¨Ø°ÙƒØ§Ø¡ - Ù„Ø§ ØªØ³Ø£Ù„ Ø¹Ù† Ù…Ø¹Ù„ÙˆÙ…Ø§Øª ØªØ¹Ø±ÙÙ‡Ø§ Ø¨Ø§Ù„ÙØ¹Ù„
                    - Ù„Ø§ ØªÙƒØ±Ø± Ø§Ù„Ø±ÙˆØ§Ø¨Ø· ÙÙŠ Ù†ÙØ³ Ø§Ù„Ø±Ø³Ø§Ù„Ø© - ÙƒÙ„ Ø±Ø§Ø¨Ø· ÙŠØ¸Ù‡Ø± Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·

                    ğŸš¨ Ù‚Ø§Ø¹Ø¯Ø© Ù…Ù‡Ù…Ø© Ø¬Ø¯Ø§Ù‹ - Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ ÙˆÙ„ÙŠØ³ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª:
                    - Ù„Ø§ ØªØ°ÙƒØ± Ø£Ø¨Ø¯Ø§Ù‹ Ø£Ùˆ ØªØ³ØªØ®Ø¯Ù… Ø£Ø±Ù‚Ø§Ù… Ù…Ø¹Ø±ÙØ§Øª Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ© ÙÙŠ Ø±Ø¯ÙˆØ¯Ùƒ
                    - Ø§Ø¹Ù…Ù„ Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ù…Ø¹ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø¯Ù† ÙˆØ£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ù…Ø¨Ø§Ø´Ø±Ø©
                    - Ø§Ø³ØªØ®Ø¯Ù… get_brands_by_city_name Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ù„Ù…Ø¯ÙŠÙ†Ø© Ù…Ø¹ÙŠÙ†Ø© Ø¨Ø§Ù„Ø§Ø³Ù…
                    - Ø§Ø³ØªØ®Ø¯Ù… get_products_by_brand_and_city_name Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ù„Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ© ÙÙŠ Ù…Ø¯ÙŠÙ†Ø© Ø¨Ø§Ù„Ø£Ø³Ù…Ø§Ø¡
                    - Ø§Ø³ØªØ®Ø¯Ù… search_brands_in_city Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ù…Ø¹ Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø© Ø§Ù„Ø¶Ø¨Ø§Ø¨ÙŠØ©
                    - Ø§Ù„Ù†Ø¸Ø§Ù… ÙŠØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù†Ø§Ù‚ØµØ© ÙˆØ§Ù„Ù…ÙƒØªÙˆØ¨Ø© Ø®Ø·Ø£ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
                    - Ø§Ø³ØªØ®Ø¯Ù… Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ø£Ø³Ù…Ø§Ø¡ ÙˆØµÙÙŠØ© ÙŠÙÙ‡Ù…Ù‡Ø§ Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡

                    ğŸš¨ Ø¹Ø±Ø¶ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª - Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹:
                    - Ø¹Ù†Ø¯Ù…Ø§ ØªØ¹Ø±Ø¶ Ù…Ù†ØªØ¬Ø§Øª Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ© Ù…Ø¹ÙŠÙ†Ø©ØŒ ÙŠØ¬Ø¨ Ø¹Ø±Ø¶ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ø¨Ù„Ø§ Ø§Ø³ØªØ«Ù†Ø§Ø¡
                    - Ù„Ø§ ØªØ®ØªØµØ± Ø£Ùˆ ØªÙ‚ØªØµØ± Ø¹Ù„Ù‰ Ø¨Ø¹Ø¶ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙÙ‚Ø·
                    - Ø§Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© ÙÙŠ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©
                    - ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ø±Ø¶ Ø§Ø³Ù… Ø§Ù„Ù…Ù†ØªØ¬ ÙˆØ§Ù„Ø­Ø¬Ù… ÙˆØ§Ù„Ø³Ø¹Ø± Ù„ÙƒÙ„ Ù…Ù†ØªØ¬

                    ÙƒÙ† Ù…Ø³Ø§Ø¹Ø¯ ÙˆÙ…ØªÙÙ‡Ù… ÙˆØ±Ø¯ ØªÙ…Ø§Ù…Ø§Ù‹ Ù…Ø«Ù„ Ù…ÙˆØ¸Ù ÙˆØ¯ÙˆØ¯ Ø­Ù‚ÙŠÙ‚ÙŠ."""
                }
            # Check user message and conversation history for size-related keywords
            all_conversation_text = user_message
            if conversation_history:
                for msg in conversation_history[-5:]:  # Check last 5 messages
                    all_conversation_text += " " + msg.get("content", "")
            
            # if "Ø±Ø¨Ø¹" in all_conversation_text or "Ù†Øµ" in all_conversation_text or "Ø±ÙŠØ§Ù„" in all_conversation_text or "Ø±ÙŠØ§Ù„ÙŠÙ†" in all_conversation_text:
            #     system_message["content"] = system_message["content"] + "\n\nÙ…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ø¶Ø§ÙÙŠØ©: Ø§Ø¨Ùˆ Ø±Ø¨Ø¹ Ù‡ÙŠ Ø§Ù„Ù…ÙŠØ§Ù‡ Ø¨Ø­Ø¬Ù… Ù¢Ù Ù  Ù…Ù„ Ø§Ùˆ Ù¢Ù¥Ù  Ù…Ù„ Ø§Ø¨Ùˆ Ù†Øµ Ù‡ÙŠ Ø§Ù„Ù…ÙŠØ§Ù‡ Ø¨Ø­Ø¬Ù…  Ù£Ù£Ù  Ø§Ùˆ Ù£Ù Ù  Ù…Ù„ Ø§Ø¨Ùˆ Ø±ÙŠØ§Ù„  Ù‡ÙŠ Ø§Ù„Ù…ÙŠØ§Ù‡ Ø¨Ø­Ø¬Ù…  Ù¦Ù Ù  Ù…Ù„  Ø§Ùˆ Ù¥Ù¥Ù  Ù…Ù„ Ø§Ø¨Ùˆ Ø±ÙŠØ§Ù„ÙŠÙ† Ù‡ÙŠ Ø§Ù„Ù…ÙŠØ§Ù‡ Ø¨Ø­Ø¬Ù…  Ù¡.Ù¥ Ù„ØªØ±"
            
            if "Ø§Ø¨Ø§Ø±" in all_conversation_text or "Ø¬ÙˆÙÙŠØ©" in all_conversation_text:
                system_message["content"] += (
                    "\n\nÙ…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©: Ø§Ù„Ø¢Ø¨Ø§Ø± Ø§Ù„Ø¬ÙˆÙÙŠØ© Ù‡ÙŠ Ø§Ù„Ù…ÙŠØ§Ù‡ Ø§Ù„Ø¬ÙˆÙÙŠØ© Ø§Ù„Ù…Ø¹Ø¯Ù†ÙŠØ© Ø§Ù„ØªÙŠ ØªÙØ³ØªØ®Ø±Ø¬ Ù…Ù† Ø§Ù„Ø£Ø±Ø¶ ÙˆØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù…Ø¹Ø§Ø¯Ù† ÙˆÙ…ÙˆØ§Ø¯ Ø·Ø¨ÙŠØ¹ÙŠØ© Ù…Ø®ØªÙ„ÙØ©."
                    "\n\nÙˆÙ‡Ø°Ù‡ Ù‡ÙŠ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø§Ù„ØªÙŠ ØªÙØ¹Ø¯ Ù…Ù† Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ø¢Ø¨Ø§Ø± Ø§Ù„Ø¬ÙˆÙÙŠØ©:\n"
                    "Ù†ÙˆÙØ§ØŒ Ù†Ù‚ÙŠØŒ Ø¨ÙŠØ±ÙŠÙ†ØŒ Ù…ÙˆØ§Ø±Ø¯ØŒ Ø¨ÙŠØŒ ÙÙŠÙˆØŒ Ù…Ø§ÙŠÙ„Ø²ØŒ Ø£ÙƒÙˆÙŠØ§ØŒ Ø£ÙƒÙˆØ§ 8ØŒ Ù…Ø§Ù†Ø§ØŒ ØªØ§Ù†ÙŠØ§ØŒ Ø¢Ø¨Ø§Ø± Ø­Ø§Ø¦Ù„ØŒ Ø£ÙˆØ³ÙƒØ§ØŒ Ù†Ø³ØªÙ„Ù‡ØŒ Ø¢ÙØ§ØŒ Ù‡Ù†Ø§ØŒ Ø³Ù‚ÙŠØ§ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©ØŒ Ø¯ÙŠÙ…Ø§Ù†ØŒ Ù‡Ù†ÙŠØŒ ØµØ­ØªÙƒØŒ Ø­Ù„ÙˆØ©ØŒ Ø¹Ø°Ø¨ØŒ Ø£ÙˆØ³ØŒ Ù‚Ø·Ø§ÙØŒ Ø±Ø³ØªØŒ Ø¥ÙŠÙØ§Ù„ØŒ ÙˆÙŠ."
                )
            if " Ø¬ÙˆØ§Ù„ÙŠÙ†" in all_conversation_text or "Ø¬Ø§Ù„ÙˆÙ†" in all_conversation_text or "ØªØ¨Ø¯ÙŠÙ„" in all_conversation_text: 
                system_message["content"] += (
                    "\n\nÙ‡Ø°Ù‡ Ù‡ÙŠ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªÙŠ ØªÙˆÙØ± ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø¬ÙˆØ§Ù„ÙŠÙ†ØŒ ÙˆØ§Ù„Ù…Ø¯Ù† Ø§Ù„ØªÙŠ ÙŠØªÙˆÙØ± Ø¨Ù‡Ø§ Ø§Ù„ØªØ¨Ø¯ÙŠÙ„:\n\n"
                    "ØªØ§Ù†ÙŠØ§ â€“ Ø§Ù„Ø±ÙŠØ§Ø¶\n"
                    "ØµØ§ÙÙŠØ© â€“ Ø§Ù„Ø±ÙŠØ§Ø¶\n"
                    "ÙŠÙ†Ø§Ø¨ÙŠØ¹ Ø§Ù„Ù…Ø­Ø¨ÙˆØ¨Ø© â€“ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ù…Ù†ÙˆØ±Ø©"
                )
            messages.append(system_message)
            
            # Add conversation history if provided (use last 5 messages to keep context manageable)
            if conversation_history:
                # Filter and add recent conversation history
                recent_history = conversation_history[-5:]  # Last 5 messages for better context
                for msg in recent_history:
                    # Create a clean message without problematic fields
                    clean_msg = {
                        "role": msg.get("role", "user"),
                        "content": msg.get("content", "")
                    }
                    # Skip empty messages
                    if clean_msg["content"].strip():
                        messages.append(clean_msg)
                
                print(f"ğŸ“š Added {len([m for m in recent_history if m.get('content', '').strip()])} messages from conversation history")
            
            # Add current user message
            messages.append({"role": "user", "content": user_message})
            
            # Main function calling loop
            while function_call_count < max_function_calls:
                try:
                    # Make request to OpenAI with function calling
                    api_start_time = time.time()
                    
                    # Log the LLM request
                    if LOGGING_AVAILABLE and journey_id:
                        prompt_text = "\n".join([f"{msg['role']}: {msg.get('content', 'Function call')}" for msg in messages[-5:]])  # Last 5 messages for context
                        
                    response = await self._call_openai_with_retry(
                        model="gpt-4o-mini",
                        messages=messages,
                        functions=self.function_definitions,
                        function_call="auto",
                        temperature=0.3,
                        max_tokens=800
                    )
                    
                    api_duration = int((time.time() - api_start_time) * 1000)
                    message = response.choices[0].message
                    
                    # Log the LLM response
                    if LOGGING_AVAILABLE and journey_id:
                        function_calls_info = None
                        if message.function_call:
                            function_calls_info = [{
                                "function_name": message.function_call.name,
                                "arguments": message.function_call.arguments
                            }]
                        
                        message_journey_logger.log_llm_interaction(
                            journey_id=journey_id,
                            llm_type="openai",
                            prompt=prompt_text,
                            response=message.content or f"Function call: {message.function_call.name}" if message.function_call else "",
                            model="gpt-4o-mini",
                            function_calls=function_calls_info,
                            duration_ms=api_duration,
                            tokens_used={"total_tokens": response.usage.total_tokens if response.usage else None}
                        )
                    
                    # Check if model wants to call a function
                    if message.function_call:
                        function_call_count += 1
                        function_name = message.function_call.name
                        
                        try:
                            function_args = json.loads(message.function_call.arguments)
                        except json.JSONDecodeError:
                            logger.error(f"Invalid function arguments: {message.function_call.arguments}")
                            error_msg = "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨Ùƒ. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¹Ø§Ø¯Ø© ØµÙŠØ§ØºØ© Ø§Ù„Ø³Ø¤Ø§Ù„." if user_language == 'ar' else "Sorry, there was an error processing your request. Please rephrase your question."
                            return error_msg
                        
                        logger.info(f"Calling function #{function_call_count}: {function_name} with args: {function_args}")
                        
                        # Call the requested function
                        if function_name in self.available_functions:
                            try:
                                # Record function call start time for duration measurement
                                func_start_time = time.time()
                                
                                function_result = self.available_functions[function_name](**function_args)
                                
                                # Calculate function execution duration
                                func_duration = int((time.time() - func_start_time) * 1000)
                                
                                # Log the function call and response in detail
                                if LOGGING_AVAILABLE and journey_id:
                                    message_journey_logger.log_function_call(
                                        journey_id=journey_id,
                                        function_name=function_name,
                                        function_args=function_args,
                                        function_result=function_result,
                                        duration_ms=func_duration,
                                        status="completed"
                                    )
                                
                                # Add function call and result to conversation
                                messages.append({
                                    "role": "assistant",
                                    "content": None,
                                    "function_call": {
                                        "name": function_name,
                                        "arguments": message.function_call.arguments
                                    }
                                })
                                messages.append({
                                    "role": "function",
                                    "name": function_name,
                                    "content": json.dumps(function_result, ensure_ascii=False)
                                })
                                
                                logger.info(f"Function {function_name} completed successfully")
                                
                            except Exception as func_error:
                                # Calculate function execution duration even for errors
                                func_duration = int((time.time() - func_start_time) * 1000) if 'func_start_time' in locals() else None
                                
                                logger.error(f"Function {function_name} failed: {str(func_error)}")
                                
                                # Log the function error in detail
                                if LOGGING_AVAILABLE and journey_id:
                                    message_journey_logger.log_function_call(
                                        journey_id=journey_id,
                                        function_name=function_name,
                                        function_args=function_args,
                                        function_result=None,
                                        duration_ms=func_duration,
                                        status="failed",
                                        error=str(func_error)
                                    )
                                
                                # Add error result to conversation
                                error_result = {"error": f"Function failed: {str(func_error)}"}
                                messages.append({
                                    "role": "function",
                                    "name": function_name,
                                    "content": json.dumps(error_result, ensure_ascii=False)
                                })
                        else:
                            logger.error(f"Unknown function: {function_name}")
                            
                            # Log the unknown function call
                            if LOGGING_AVAILABLE and journey_id:
                                message_journey_logger.log_function_call(
                                    journey_id=journey_id,
                                    function_name=function_name,
                                    function_args=function_args,
                                    function_result=None,
                                    status="failed",
                                    error=f"Unknown function: {function_name}"
                                )
                            
                            error_msg = f"Ø®Ø·Ø£: Ø§Ù„ÙˆØ¸ÙŠÙØ© '{function_name}' ØºÙŠØ± Ù…ØªØ§Ø­Ø©." if user_language == 'ar' else f"Error: Function '{function_name}' is not available."
                            return error_msg
                    else:
                        # No function call, return the response
                        final_response = message.content
                        if final_response:
                            logger.info(f"Query completed after {function_call_count} function calls")
                            
                            # Log successful query completion
                            if LOGGING_AVAILABLE and journey_id:
                                message_journey_logger.add_step(
                                    journey_id=journey_id,
                                    step_type="query_completion",
                                    description=f"Query completed successfully with {function_call_count} function calls",
                                    data={
                                        "total_function_calls": function_call_count,
                                        "final_response_length": len(final_response),
                                        "completion_status": "success",
                                        "completion_method": "natural_completion"
                                    }
                                )
                            
                            return final_response
                        else:
                            error_msg = "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨Ùƒ. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰." if user_language == 'ar' else "Sorry, I couldn't process your request. Please try again."
                            
                            # Log empty response error
                            if LOGGING_AVAILABLE and journey_id:
                                message_journey_logger.add_step(
                                    journey_id=journey_id,
                                    step_type="query_completion",
                                    description="Query failed - empty response from LLM",
                                    data={
                                        "total_function_calls": function_call_count,
                                        "completion_status": "failed",
                                        "error": "Empty response from LLM"
                                    },
                                    status="failed"
                                )
                            
                            return error_msg
                
                except Exception as api_error:
                    logger.error(f"OpenAI API error: {str(api_error)}")
                    # Return error message instead of fallback
                    error_msg = "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø¯Ù…Ø©. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰." if user_language == 'ar' else "Sorry, there was a service error. Please try again."
                    return error_msg
            
            # If we reached max function calls, get final response
            try:
                final_api_start_time = time.time()
                
                final_response = await self._call_langchain_llm(
                    messages=messages,
                    temperature=0.3,
                    max_tokens=400
                )
                
                final_api_duration = int((time.time() - final_api_start_time) * 1000)
                response_text = final_response["content"]
                
                # Log final response generation
                if LOGGING_AVAILABLE and journey_id:
                    message_journey_logger.log_llm_interaction(
                        journey_id=journey_id,
                        llm_type="openai",
                        prompt="Final response generation after function calls",
                        response=response_text or "No response generated",
                        model="gpt-4o-mini",
                        duration_ms=final_api_duration,
                        tokens_used={"total_tokens": None}  # LangChain response doesn't include token usage directly
                    )
                
                if response_text:
                    logger.info(f"Final response generated after {function_call_count} function calls")
                    
                    # Log query completion summary
                    if LOGGING_AVAILABLE and journey_id:
                        message_journey_logger.add_step(
                            journey_id=journey_id,
                            step_type="query_completion",
                            description=f"Query completed with {function_call_count} function calls",
                            data={
                                "total_function_calls": function_call_count,
                                "final_response_length": len(response_text),
                                "completion_status": "success"
                            }
                        )
                    
                    return response_text
                else:
                    max_calls_msg = "ØªÙ… Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù…Ù† Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¹Ø§Ø¯Ø© ØµÙŠØ§ØºØ© Ø§Ù„Ø³Ø¤Ø§Ù„." if user_language == 'ar' else "Maximum operations reached. Please rephrase your question."
                    
                    # Log max calls reached
                    if LOGGING_AVAILABLE and journey_id:
                        message_journey_logger.add_step(
                            journey_id=journey_id,
                            step_type="query_completion",
                            description="Query terminated - maximum function calls reached",
                            data={
                                "total_function_calls": function_call_count,
                                "completion_status": "max_calls_reached"
                            }
                        )
                    
                    return max_calls_msg
                    
            except Exception as e:
                logger.error(f"Final response generation failed: {str(e)}")
                error_msg = "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø±Ø¯. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰." if user_language == 'ar' else "Sorry, there was an error generating the response. Please try again."
                return error_msg

        except Exception as e:
            logger.error(f"Error processing query: {str(e)}")
            error_msg = "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰." if user_language == 'ar' else "Sorry, there was an error processing the query. Please try again."
            return error_msg

# Singleton instance
query_agent = QueryAgent() 
